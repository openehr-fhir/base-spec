{
    "bmm_version": "2.4",
    "rm_publisher": "openehr",
    "schema_name": "rm",
    "rm_release": "1.2.0",
    "schema_revision": "1.2.0.2",
    "schema_lifecycle_state": "stable",
    "schema_description": "openEHR Reference Model",
    "schema_author": "Thomas Beale <thomas.beale@openehr.org>, code-generator",
    "packages": {
        "org.openehr.rm.common": {
            "name": "org.openehr.rm.common",
            "packages": {
                "archetyped": {
                    "name": "archetyped",
                    "classes": [
                        "PATHABLE",
                        "LINK",
                        "LOCATABLE",
                        "ARCHETYPED",
                        "FEEDER_AUDIT",
                        "FEEDER_AUDIT_DETAILS"
                    ]
                },
                "change_control": {
                    "name": "change_control",
                    "classes": [
                        "VERSIONED_OBJECT",
                        "CONTRIBUTION",
                        "VERSION",
                        "IMPORTED_VERSION",
                        "ORIGINAL_VERSION"
                    ]
                },
                "generic": {
                    "name": "generic",
                    "classes": [
                        "REVISION_HISTORY_ITEM",
                        "AUDIT_DETAILS",
                        "ATTESTATION",
                        "PARTICIPATION",
                        "PARTY_PROXY",
                        "PARTY_IDENTIFIED",
                        "PARTY_SELF",
                        "PARTY_RELATED",
                        "REVISION_HISTORY"
                    ]
                },
                "directory": {
                    "name": "directory",
                    "classes": [
                        "VERSIONED_FOLDER",
                        "FOLDER"
                    ]
                },
                "resource": {
                    "name": "resource",
                    "classes": [
                        "AUTHORED_RESOURCE",
                        "RESOURCE_DESCRIPTION",
                        "TRANSLATION_DETAILS",
                        "RESOURCE_DESCRIPTION_ITEM"
                    ]
                },
                "tags": {
                    "name": "tags",
                    "classes": [
                        "ITEM_TAG"
                    ]
                }
            }
        },
        "org.openehr.rm.data_structures": {
            "name": "org.openehr.rm.data_structures",
            "packages": {
                "item_structure": {
                    "name": "item_structure",
                    "classes": [
                        "ITEM_STRUCTURE",
                        "ITEM_TREE",
                        "ITEM_SINGLE",
                        "ITEM_TABLE",
                        "ITEM_LIST"
                    ]
                },
                "history": {
                    "name": "history",
                    "classes": [
                        "EVENT",
                        "POINT_EVENT",
                        "INTERVAL_EVENT",
                        "HISTORY"
                    ]
                },
                "representation": {
                    "name": "representation",
                    "classes": [
                        "ITEM",
                        "CLUSTER",
                        "ELEMENT"
                    ]
                }
            },
            "classes": [
                "DATA_STRUCTURE"
            ]
        },
        "org.openehr.rm.data_types": {
            "name": "org.openehr.rm.data_types",
            "packages": {
                "basic": {
                    "name": "basic",
                    "classes": [
                        "DATA_VALUE",
                        "DV_BOOLEAN",
                        "DV_STATE",
                        "DV_IDENTIFIER"
                    ]
                },
                "encapsulated": {
                    "name": "encapsulated",
                    "classes": [
                        "DV_ENCAPSULATED",
                        "DV_MULTIMEDIA",
                        "DV_PARSABLE"
                    ]
                },
                "text": {
                    "name": "text",
                    "classes": [
                        "DV_PARAGRAPH",
                        "DV_TEXT",
                        "DV_CODED_TEXT",
                        "TERM_MAPPING",
                        "CODE_PHRASE"
                    ]
                },
                "quantity": {
                    "name": "quantity",
                    "packages": {
                        "date_time": {
                            "name": "date_time",
                            "classes": [
                                "DV_DURATION",
                                "DV_TEMPORAL",
                                "DV_DATE",
                                "DV_TIME",
                                "DV_DATE_TIME"
                            ]
                        }
                    },
                    "classes": [
                        "DV_ORDERED",
                        "DV_INTERVAL",
                        "REFERENCE_RANGE",
                        "DV_QUANTIFIED",
                        "DV_PROPORTION",
                        "PROPORTION_KIND",
                        "DV_AMOUNT",
                        "DV_QUANTITY",
                        "DV_COUNT",
                        "DV_ABSOLUTE_QUANTITY",
                        "DV_ORDINAL",
                        "DV_SCALE"
                    ]
                },
                "time_specification": {
                    "name": "time_specification",
                    "classes": [
                        "DV_TIME_SPECIFICATION",
                        "DV_PERIODIC_TIME_SPECIFICATION",
                        "DV_GENERAL_TIME_SPECIFICATION"
                    ]
                },
                "uri": {
                    "name": "uri",
                    "classes": [
                        "DV_URI",
                        "DV_EHR_URI"
                    ]
                }
            }
        },
        "org.openehr.rm.support": {
            "name": "org.openehr.rm.support",
            "packages": {
                "measurement": {
                    "name": "measurement",
                    "classes": [
                        "MEASUREMENT_SERVICE"
                    ]
                },
                "terminology": {
                    "name": "terminology",
                    "classes": [
                        "OPENEHR_TERMINOLOGY_GROUP_IDENTIFIERS",
                        "OPENEHR_CODE_SET_IDENTIFIERS",
                        "TERMINOLOGY_SERVICE",
                        "CODE_SET_ACCESS",
                        "TERMINOLOGY_ACCESS"
                    ]
                }
            },
            "classes": [
                "EXTERNAL_ENVIRONMENT_ACCESS"
            ]
        },
        "org.openehr.rm.security": {
            "name": "org.openehr.rm.security"
        },
        "org.openehr.rm.ehr": {
            "name": "org.openehr.rm.ehr",
            "classes": [
                "EHR",
                "VERSIONED_EHR_ACCESS",
                "VERSIONED_EHR_STATUS",
                "VERSIONED_COMPOSITION",
                "EHR_ACCESS",
                "EHR_STATUS",
                "ACCESS_CONTROL_SETTINGS"
            ]
        },
        "org.openehr.rm.ehr_extract": {
            "name": "org.openehr.rm.ehr_extract",
            "packages": {
                "common": {
                    "name": "common",
                    "classes": [
                        "EXTRACT",
                        "EXTRACT_ACTION_REQUEST",
                        "EXTRACT_CHAPTER",
                        "EXTRACT_CONTENT_ITEM",
                        "EXTRACT_ENTITY_CHAPTER",
                        "EXTRACT_ENTITY_MANIFEST",
                        "EXTRACT_ERROR",
                        "EXTRACT_FOLDER",
                        "EXTRACT_ITEM",
                        "EXTRACT_MANIFEST",
                        "EXTRACT_PARTICIPATION",
                        "EXTRACT_REQUEST",
                        "EXTRACT_SPEC",
                        "EXTRACT_UPDATE_SPEC",
                        "EXTRACT_VERSION_SPEC"
                    ]
                },
                "openehr_extract": {
                    "name": "openehr_extract",
                    "classes": [
                        "OPENEHR_CONTENT_ITEM",
                        "X_VERSIONED_OBJECT",
                        "X_VERSIONED_EHR_ACCESS",
                        "X_VERSIONED_EHR_STATUS",
                        "X_VERSIONED_COMPOSITION",
                        "X_VERSIONED_FOLDER",
                        "X_VERSIONED_PARTY"
                    ]
                },
                "generic_extract": {
                    "name": "generic_extract",
                    "classes": [
                        "GENERIC_CONTENT_ITEM"
                    ]
                },
                "sync_extract": {
                    "name": "sync_extract",
                    "classes": [
                        "SYNC_EXTRACT_REQUEST",
                        "SYNC_EXTRACT",
                        "X_CONTRIBUTION",
                        "SYNC_EXTRACT_SPEC"
                    ]
                },
                "message": {
                    "name": "message",
                    "classes": [
                        "MESSAGE",
                        "ADDRESSED_MESSAGE",
                        "MESSAGE_CONTENT"
                    ]
                }
            }
        },
        "org.openehr.rm.demographic": {
            "name": "org.openehr.rm.demographic",
            "classes": [
                "PARTY",
                "CONTACT",
                "ADDRESS",
                "PARTY_IDENTITY",
                "ROLE",
                "ACTOR",
                "CAPABILITY",
                "AGENT",
                "ORGANISATION",
                "GROUP",
                "PERSON",
                "PARTY_RELATIONSHIP",
                "VERSIONED_PARTY"
            ]
        },
        "org.openehr.rm.integration": {
            "name": "org.openehr.rm.integration",
            "classes": [
                "GENERIC_ENTRY"
            ]
        },
        "org.openehr.rm.composition": {
            "name": "org.openehr.rm.composition",
            "packages": {
                "content": {
                    "name": "content",
                    "packages": {
                        "navigation": {
                            "name": "navigation",
                            "classes": [
                                "SECTION"
                            ]
                        },
                        "entry": {
                            "name": "entry",
                            "classes": [
                                "ADMIN_ENTRY",
                                "CARE_ENTRY",
                                "OBSERVATION",
                                "EVALUATION",
                                "ACTION",
                                "ACTIVITY",
                                "ISM_TRANSITION",
                                "INSTRUCTION_DETAILS",
                                "ENTRY",
                                "INSTRUCTION"
                            ]
                        }
                    },
                    "classes": [
                        "CONTENT_ITEM"
                    ]
                }
            },
            "classes": [
                "COMPOSITION",
                "EVENT_CONTEXT"
            ]
        }
    },
    "class_definitions": {
        "PATHABLE": {
            "name": "PATHABLE",
            "documentation": "The `PATHABLE` class defines the pathing capabilities used by nearly all classes in the openEHR reference model, mostly via inheritance of `LOCATABLE`. The defining characteristics of `PATHABLE` objects are that they can locate child objects using paths, and they know their parent object in a compositional hierarchy. The parent feature is defined as abstract in the model, and may be implemented in any way convenient.",
            "is_abstract": true,
            "ancestors": [
                "Any"
            ],
            "functions": {
                "parent": {
                    "name": "parent",
                    "documentation": "Parent of this node in a compositional hierarchy. \n",
                    "result": {
                        "type": "PATHABLE"
                    }
                },
                "item_at_path": {
                    "name": "item_at_path",
                    "documentation": "The item at a path (relative to this item); only valid for unique paths, i.e. paths that resolve to a single item. ",
                    "parameters": {
                        "a_path": {
                            "name": "a_path",
                            "type": "String"
                        }
                    },
                    "pre_conditions": {
                        "Pre": "path_unique (a_path)"
                    },
                    "result": {
                        "type": "Any"
                    }
                },
                "items_at_path": {
                    "name": "items_at_path",
                    "documentation": "List of items corresponding to a non-unique path.",
                    "parameters": {
                        "a_path": {
                            "name": "a_path",
                            "type": "String"
                        }
                    },
                    "result": {
                        "_type": "P_BMM_CONTAINER_TYPE",
                        "container_type": "List",
                        "type": "Any"
                    },
                    "is_nullable": true
                },
                "path_exists": {
                    "name": "path_exists",
                    "documentation": "True if the path exists in the data with respect to the current item. ",
                    "parameters": {
                        "a_path": {
                            "name": "a_path",
                            "type": "String"
                        }
                    },
                    "pre_conditions": {
                        "Pre": "not a_path.is_empty"
                    },
                    "result": {
                        "type": "Boolean"
                    }
                },
                "path_unique": {
                    "name": "path_unique",
                    "documentation": "True if the path corresponds to a single item in the data. ",
                    "parameters": {
                        "a_path": {
                            "name": "a_path",
                            "type": "String"
                        }
                    },
                    "pre_conditions": {
                        "Pre": "path_exists (a_path)"
                    },
                    "result": {
                        "type": "Boolean"
                    }
                },
                "path_of_item": {
                    "name": "path_of_item",
                    "documentation": "The path to an item relative to the root of this archetyped structure.",
                    "parameters": {
                        "a_loc": {
                            "name": "a_loc",
                            "type": "PATHABLE"
                        }
                    },
                    "result": {
                        "type": "String"
                    }
                }
            }
        },
        "LINK": {
            "name": "LINK",
            "documentation": "The `LINK` type defines a logical relationship between two items, such as two `ENTRYs` or an `ENTRY` and a `COMPOSITION`. Links can be used across compositions, and across EHRs. Links can potentially be used between interior (i.e. non archetype root) nodes, although this probably should be prevented in archetypes. Multiple `LINKs` can be attached to the root object of any archetyped structure to give the effect of a 1->N link.\n\n1:1 and 1:N relationships between archetyped content elements (e.g. `ENTRYs`) can be expressed by using one, or more than one, respectively, `LINKs`. Chains of links can be used to see  problem threads  or other logical groupings of items. \n\nLinks should be between archetyped structures only, i.e. between objects representing complete domain concepts because relationships between sub-elements of whole concepts are not necessarily meaningful, and may be downright confusing. Sensible links only exist between whole `ENTRYs`, `SECTIONs`, `COMPOSITIONs` and so on. ",
            "properties": {
                "meaning": {
                    "name": "meaning",
                    "documentation": "Used to describe the relationship, usually in clinical terms, such as  in response to  (the relationship between test results and an order),  follow-up to  and so on. Such relationships can represent any clinically meaningful connection between pieces of information. Values for meaning include those described in Annex C, ENV 13606 pt 2 under the categories of  generic ,  documenting and reporting ,  organisational ,  clinical ,  circumstancial , and  view management .",
                    "is_mandatory": true,
                    "type": "DV_TEXT"
                },
                "type": {
                    "name": "type",
                    "documentation": "The type attribute is used to indicate a clinical or domain-level meaning for the kind of link, for example  problem  or  issue . If type values are designed appropriately, they can be used by the requestor of EHR extracts to categorise links which must be followed and which can be broken when the extract is created. \n",
                    "is_mandatory": true,
                    "type": "DV_TEXT"
                },
                "target": {
                    "name": "target",
                    "documentation": "The logical  to  object in the link relation, as per the linguistic sense of the meaning attribute.",
                    "is_mandatory": true,
                    "type": "DV_EHR_URI"
                }
            }
        },
        "LOCATABLE": {
            "name": "LOCATABLE",
            "documentation": "Root class of all information model classes that can be archetyped. Most classes in the openEHR reference model inherit from the `LOCATABLE` class, which defines the idea of  locatability in an archetyped structure. `LOCATABLE` defines a runtime name and an `_archetype_node_id_`. ",
            "is_abstract": true,
            "ancestors": [
                "PATHABLE"
            ],
            "properties": {
                "name": {
                    "name": "name",
                    "documentation": "Runtime name of this fragment, used to build runtime paths. This is the term provided via a clinical application or batch process to name this EHR construct: its retention in the EHR faithfully preserves the original label by which this entry was known to end users. \n",
                    "is_mandatory": true,
                    "type": "DV_TEXT"
                },
                "archetype_node_id": {
                    "name": "archetype_node_id",
                    "documentation": "Design-time archetype identifier of this node taken from its generating archetype; used to build archetype paths. Always in the form of an at-code, e.g.  `at0005`. This value enables a 'standardised' name for this node to be generated, by referring to the generating archetype local terminology. \n\nAt an archetype root point, the value of this attribute is always the stringified form of the `_archetype_id_` found in the `_archetype_details_` object. \n",
                    "is_mandatory": true,
                    "type": "String"
                },
                "uid": {
                    "name": "uid",
                    "documentation": "Optional globally unique object identifier for root points of archetyped structures. ",
                    "type": "UID_BASED_ID"
                },
                "links": {
                    "_type": "P_BMM_CONTAINER_PROPERTY",
                    "name": "links",
                    "documentation": "Links to other archetyped structures (data whose root object inherits from `ARCHETYPED`, such as `ENTRY`, `SECTION` and so on). Links may be to structures in other compositions. ",
                    "type_def": {
                        "container_type": "List",
                        "type": "LINK"
                    },
                    "cardinality": {
                        "lower": 0,
                        "upper_unbounded": true
                    }
                },
                "archetype_details": {
                    "name": "archetype_details",
                    "documentation": "Details of archetyping used on this node.",
                    "type": "ARCHETYPED"
                },
                "feeder_audit": {
                    "name": "feeder_audit",
                    "documentation": "Audit trail from non-openEHR system of original commit of information forming the content of this node, or from a conversion gateway which has synthesised this node. ",
                    "type": "FEEDER_AUDIT"
                }
            },
            "functions": {
                "concept": {
                    "name": "concept",
                    "documentation": "Clinical concept of the archetype as a whole (= derived from the archetype_node_id' of the root node) ",
                    "result": {
                        "type": "DV_TEXT"
                    }
                },
                "is_archetype_root": {
                    "name": "is_archetype_root",
                    "documentation": "True if this node is the root of an archetyped structure.",
                    "result": {
                        "type": "Boolean"
                    }
                }
            },
            "invariants": {
                "Links_valid": "links \/= Void implies not links.is_empty",
                "Archetyped_valid": "is_archetype_root xor archetype_details = Void",
                "Archetype_node_id_valid": "not archetype_node_id.is_empty"
            }
        },
        "ARCHETYPED": {
            "name": "ARCHETYPED",
            "documentation": "Archetypes act as the configuration basis for the particular structures of instances defined by the reference model. To enable archetypes to be used to create valid data, key classes in the reference model act as  root  points for archetyping; accordingly, these classes have the `_archetype_details_` attribute set. \n\nAn instance of the class `ARCHETYPED` contains the relevant archetype identification information, allowing generating archetypes to be matched up with data instances.",
            "properties": {
                "archetype_id": {
                    "name": "archetype_id",
                    "documentation": "Globally unique archetype identifier. ",
                    "is_mandatory": true,
                    "type": "ARCHETYPE_ID"
                },
                "template_id": {
                    "name": "template_id",
                    "documentation": "Globally unique template identifier, if a template was active at this point in the structure. Normally, a template would only be used at the top of a top-level structure, but the possibility exists for templates at lower levels. ",
                    "type": "TEMPLATE_ID"
                },
                "rm_version": {
                    "name": "rm_version",
                    "documentation": "Version of the openEHR reference model used to create this object. Expressed in terms of the release version string, e.g.  1.0 ,  1.2.4 .",
                    "is_mandatory": true,
                    "type": "String"
                }
            },
            "invariants": {
                "rm_version_valid": "not rm_version.is_empty",
                "Rm_version_valid": "not rm_version.is_empty"
            }
        },
        "FEEDER_AUDIT": {
            "name": "FEEDER_AUDIT",
            "documentation": "The `FEEDER_AUDIT` class defines the semantics of an audit trail which is constructed to describe the origin of data that have been transformed into openEHR form and committed to the system. ",
            "properties": {
                "originating_system_item_ids": {
                    "_type": "P_BMM_CONTAINER_PROPERTY",
                    "name": "originating_system_item_ids",
                    "documentation": "Identifiers used for the item in the originating system, e.g. filler and placer ids. ",
                    "type_def": {
                        "container_type": "List",
                        "type": "DV_IDENTIFIER"
                    },
                    "cardinality": {
                        "lower": 0,
                        "upper_unbounded": true
                    }
                },
                "feeder_system_item_ids": {
                    "_type": "P_BMM_CONTAINER_PROPERTY",
                    "name": "feeder_system_item_ids",
                    "documentation": "Identifiers used for the item in the feeder system, where the feeder system is distinct from the originating system. ",
                    "type_def": {
                        "container_type": "List",
                        "type": "DV_IDENTIFIER"
                    },
                    "cardinality": {
                        "lower": 0,
                        "upper_unbounded": true
                    }
                },
                "original_content": {
                    "name": "original_content",
                    "documentation": "Optional inline inclusion of or reference to original content corresponding to the openEHR content at this node. Typically a URI reference to a document or message in a persistent store associated with the EHR. ",
                    "type": "DV_ENCAPSULATED"
                },
                "originating_system_audit": {
                    "name": "originating_system_audit",
                    "documentation": "Any audit information for the information item from the originating system. ",
                    "is_mandatory": true,
                    "type": "FEEDER_AUDIT_DETAILS"
                },
                "feeder_system_audit": {
                    "name": "feeder_system_audit",
                    "documentation": "Any audit information for the information item from the feeder system, if different from the originating system.",
                    "type": "FEEDER_AUDIT_DETAILS"
                }
            }
        },
        "FEEDER_AUDIT_DETAILS": {
            "name": "FEEDER_AUDIT_DETAILS",
            "documentation": "Audit details for any system in a feeder system chain. Audit details here means the general notion of who\/where\/when the information item to which the audit is attached was created. None of the attributes is defined as mandatory, however, in different scenarios, various combinations of attributes will usually be mandatory. This can be controlled by specifying feeder audit details in legacy archetypes. ",
            "properties": {
                "system_id": {
                    "name": "system_id",
                    "documentation": "Identifier of the system which handled the information item. This is the IT system owned by the organisation legally responsible for handling the data, and at which the data were previously created or passed by an earlier system.\n",
                    "is_mandatory": true,
                    "type": "String"
                },
                "location": {
                    "name": "location",
                    "documentation": "Identifier of the particular site\/facility within an organisation which handled the item. For computability, this identifier needs to be e.g. a PKI identifier which can be included in the identifier list of the `PARTY_IDENTIFIED` object. ",
                    "type": "PARTY_IDENTIFIED"
                },
                "subject": {
                    "name": "subject",
                    "documentation": "Identifiers for subject of the received information item. ",
                    "type": "PARTY_PROXY"
                },
                "provider": {
                    "name": "provider",
                    "documentation": "Optional provider(s) who created, committed, forwarded or otherwise handled the item. ",
                    "type": "PARTY_IDENTIFIED"
                },
                "time": {
                    "name": "time",
                    "documentation": "Time of handling the item. For an originating system, this will be time of creation, for an intermediate feeder system, this will be a time of accession or other time of handling, where available.",
                    "type": "DV_DATE_TIME"
                },
                "version_id": {
                    "name": "version_id",
                    "documentation": "Any identifier used in the system such as  \"interim\" ,  \"final\" , or numeric versions if available. ",
                    "type": "String"
                },
                "other_details": {
                    "name": "other_details",
                    "documentation": "Optional attribute to carry any custom meta-data. May be archetyped.",
                    "type": "ITEM_STRUCTURE"
                }
            },
            "invariants": {
                "System_id_valid": "not system_id.is_empty"
            }
        },
        "VERSIONED_OBJECT": {
            "name": "VERSIONED_OBJECT",
            "documentation": "Version control abstraction, defining semantics for versioning one complex object.",
            "generic_parameter_defs": {
                "T": {
                    "name": "T"
                }
            },
            "properties": {
                "uid": {
                    "name": "uid",
                    "documentation": "Unique identifier of this version container in the form of a UID with no extension. This id will be the same in all instances of the same container in a distributed environment, meaning that it can be understood as the uid of the  virtual version tree. ",
                    "is_mandatory": true,
                    "type": "HIER_OBJECT_ID"
                },
                "owner_id": {
                    "name": "owner_id",
                    "documentation": "Reference to object to which this version container belongs, e.g. the id of the containing EHR or other relevant owning entity. ",
                    "is_mandatory": true,
                    "type": "OBJECT_REF"
                },
                "time_created": {
                    "name": "time_created",
                    "documentation": "Time of initial creation of this versioned object. ",
                    "is_mandatory": true,
                    "type": "DV_DATE_TIME"
                }
            },
            "functions": {
                "version_count": {
                    "name": "version_count",
                    "documentation": "Return the total number of versions in this object.",
                    "result": {
                        "type": "Integer"
                    }
                },
                "all_version_ids": {
                    "name": "all_version_ids",
                    "documentation": "Return a list of ids of all versions in this object. ",
                    "result": {
                        "_type": "P_BMM_CONTAINER_TYPE",
                        "container_type": "List",
                        "type": "OBJECT_VERSION_ID"
                    }
                },
                "all_versions": {
                    "name": "all_versions",
                    "documentation": "Return a list of all versions in this object. ",
                    "result": {
                        "_type": "P_BMM_CONTAINER_TYPE",
                        "container_type": "List",
                        "type_def": {
                            "_type": "P_BMM_GENERIC_TYPE",
                            "root_type": "VERSION",
                            "generic_parameters": [
                                "T"
                            ]
                        }
                    }
                },
                "has_version_at_time": {
                    "name": "has_version_at_time",
                    "documentation": "True if a version for time  `_a_time_` exists. ",
                    "parameters": {
                        "a_time": {
                            "name": "a_time",
                            "type": "DV_DATE_TIME"
                        }
                    },
                    "result": {
                        "type": "Boolean"
                    }
                },
                "has_version_id": {
                    "name": "has_version_id",
                    "documentation": "True if a version with `_a_version_uid_` exists. ",
                    "parameters": {
                        "a_version_uid": {
                            "name": "a_version_uid",
                            "type": "OBJECT_VERSION_ID"
                        }
                    },
                    "result": {
                        "type": "Boolean"
                    }
                },
                "version_with_id": {
                    "name": "version_with_id",
                    "documentation": "Return the version with `_uid_` =  `_a_version_uid_`. \n",
                    "parameters": {
                        "a_version_uid": {
                            "name": "a_version_uid",
                            "type": "OBJECT_VERSION_ID"
                        }
                    },
                    "pre_conditions": {
                        "Pre": "has_version_id (a_ver_id)"
                    },
                    "result": {
                        "type": "VERSION"
                    }
                },
                "is_original_version": {
                    "name": "is_original_version",
                    "documentation": "True if version with `_a_version_uid_` is an `ORIGINAL_VERSION`. ",
                    "parameters": {
                        "a_version_uid": {
                            "name": "a_version_uid",
                            "type": "OBJECT_VERSION_ID"
                        }
                    },
                    "pre_conditions": {
                        "Pre": "has_version_id(a_ver_id)"
                    },
                    "result": {
                        "type": "Boolean"
                    }
                },
                "version_at_time": {
                    "name": "version_at_time",
                    "documentation": "Return the version for time  `_a_time_`. ",
                    "parameters": {
                        "a_time": {
                            "name": "a_time",
                            "type": "DV_DATE_TIME"
                        }
                    },
                    "pre_conditions": {
                        "Pre": "has_version_at_time (a_time)"
                    },
                    "result": {
                        "type": "VERSION"
                    }
                },
                "revision_history": {
                    "name": "revision_history",
                    "documentation": "History of all audits and attestations in this versioned repository.",
                    "result": {
                        "type": "REVISION_HISTORY"
                    }
                },
                "latest_version": {
                    "name": "latest_version",
                    "documentation": "Return the most recently added version (i.e. on trunk or any branch). ",
                    "result": {
                        "type": "VERSION"
                    }
                },
                "latest_trunk_version": {
                    "name": "latest_trunk_version",
                    "documentation": "Return the most recently added trunk version. ",
                    "result": {
                        "type": "VERSION"
                    }
                },
                "trunk_lifecycle_state": {
                    "name": "trunk_lifecycle_state",
                    "documentation": "Return the lifecycle state from the latest trunk version. Useful for determining if the version container is logically deleted. ",
                    "post_conditions": {
                        "Post": "Result = latest_trunk_version.lifecycle_state"
                    },
                    "result": {
                        "type": "DV_CODED_TEXT"
                    }
                },
                "commit_original_version": {
                    "name": "commit_original_version",
                    "documentation": "Add a new original version. ",
                    "parameters": {
                        "a_contribution": {
                            "name": "a_contribution",
                            "type": "OBJECT_REF"
                        },
                        "a_new_version_uid": {
                            "name": "a_new_version_uid",
                            "type": "OBJECT_VERSION_ID"
                        },
                        "a_preceding_version_id": {
                            "name": "a_preceding_version_id",
                            "type": "OBJECT_VERSION_ID"
                        },
                        "an_audit": {
                            "name": "an_audit",
                            "type": "AUDIT_DETAILS"
                        },
                        "a_lifecycle_state": {
                            "name": "a_lifecycle_state",
                            "type": "DV_CODED_TEXT"
                        },
                        "a_data": {
                            "name": "a_data",
                            "type": "T"
                        },
                        "signing_key": {
                            "name": "signing_key",
                            "type": "String"
                        }
                    },
                    "pre_conditions": {
                        "Pre": "all_version_ids.has (a_preceding_version_uid) or else version_count = 0"
                    },
                    "result": {
                        "type": "void"
                    }
                },
                "commit_original_merged_version": {
                    "name": "commit_original_merged_version",
                    "documentation": "Add a new original merged version. This commit function adds a parameter containing the ids of other versions merged into the current one. ",
                    "parameters": {
                        "a_contribution": {
                            "name": "a_contribution",
                            "type": "OBJECT_REF"
                        },
                        "a_new_version_uid": {
                            "name": "a_new_version_uid",
                            "type": "OBJECT_VERSION_ID"
                        },
                        "a_preceding_version_id": {
                            "name": "a_preceding_version_id",
                            "type": "OBJECT_VERSION_ID"
                        },
                        "an_audit": {
                            "name": "an_audit",
                            "type": "AUDIT_DETAILS"
                        },
                        "a_lifecycle_state": {
                            "name": "a_lifecycle_state",
                            "type": "DV_CODED_TEXT"
                        },
                        "a_data": {
                            "name": "a_data",
                            "type": "T"
                        },
                        "an_other_input_uids": {
                            "_type": "P_BMM_CONTAINER_FUNCTION_PARAMETER",
                            "name": "an_other_input_uids",
                            "type_def": {
                                "container_type": "List",
                                "type": "OBJECT_VERSION_ID"
                            },
                            "cardinality": {
                                "lower": 1,
                                "upper_unbounded": true
                            }
                        },
                        "signing_key": {
                            "name": "signing_key",
                            "type": "String"
                        }
                    },
                    "pre_conditions": {
                        "Pre": "all_version_ids.has (a_preceding_version_uid) or else version_count = 0"
                    },
                    "result": {
                        "type": "void"
                    }
                },
                "commit_imported_version": {
                    "name": "commit_imported_version",
                    "documentation": "Add a new imported version. Details of version id etc come from the `ORIGINAL_VERSION` being committed. ",
                    "parameters": {
                        "a_contribution": {
                            "name": "a_contribution",
                            "type": "OBJECT_REF"
                        },
                        "an_audit": {
                            "name": "an_audit",
                            "type": "AUDIT_DETAILS"
                        },
                        "a_version": {
                            "name": "a_version",
                            "type": "ORIGINAL_VERSION"
                        }
                    },
                    "result": {
                        "type": "void"
                    }
                },
                "commit_attestation": {
                    "name": "commit_attestation",
                    "documentation": "Add a new attestation to a specified original version. Attestations can only be added to Original versions. ",
                    "parameters": {
                        "an_attestation": {
                            "name": "an_attestation",
                            "type": "ATTESTATION"
                        },
                        "a_ver_id": {
                            "name": "a_ver_id",
                            "type": "OBJECT_VERSION_ID"
                        },
                        "signing_key": {
                            "name": "signing_key",
                            "type": "String"
                        }
                    },
                    "pre_conditions": {
                        "Pre": "has_version_id(a_ver_id)\nand is_original_version(a_ver_id)"
                    },
                    "result": {
                        "type": "void"
                    }
                }
            },
            "invariants": {
                "Version_count_valid": "version_count >= 0",
                "All_version_ids_valid": "all_version_ids.count = version_count",
                "All_versions_valid": "all_versions.count = version_count",
                "Latest_version_valid": "version_count > 0 implies latest_version \/= Void",
                "Uid_validity": "extension.is_empty"
            }
        },
        "CONTRIBUTION": {
            "name": "CONTRIBUTION",
            "documentation": "Documents a Contribution (change set) of one or more versions added to a change-controlled repository. ",
            "properties": {
                "uid": {
                    "name": "uid",
                    "documentation": "Unique identifier for this Contribution. ",
                    "is_mandatory": true,
                    "type": "HIER_OBJECT_ID"
                },
                "versions": {
                    "_type": "P_BMM_CONTAINER_PROPERTY",
                    "name": "versions",
                    "documentation": "Set of references to Versions causing changes to this EHR. Each contribution contains a list of versions, which may include paths pointing to any number of versionable items, i.e. items of types such as `COMPOSITION` and `FOLDER`. ",
                    "is_mandatory": true,
                    "type_def": {
                        "container_type": "List",
                        "type": "OBJECT_REF"
                    },
                    "cardinality": {
                        "lower": 1,
                        "upper_unbounded": true
                    }
                },
                "audit": {
                    "name": "audit",
                    "documentation": "Audit trail corresponding to the committal of this Contribution. ",
                    "is_mandatory": true,
                    "type": "AUDIT_DETAILS"
                }
            }
        },
        "VERSION": {
            "name": "VERSION",
            "documentation": "Abstract model of one Version within a Version container, containing data, commit audit trail, and the identifier of its Contribution.",
            "is_abstract": true,
            "generic_parameter_defs": {
                "T": {
                    "name": "T"
                }
            },
            "properties": {
                "contribution": {
                    "name": "contribution",
                    "documentation": "Contribution in which this version was added. ",
                    "is_mandatory": true,
                    "type": "OBJECT_REF"
                },
                "signature": {
                    "name": "signature",
                    "documentation": "OpenPGP digital signature or digest of content committed in this Version. ",
                    "type": "String"
                },
                "commit_audit": {
                    "name": "commit_audit",
                    "documentation": "Audit trail corresponding to the committal of this version to the `VERSIONED_OBJECT`.",
                    "is_mandatory": true,
                    "type": "AUDIT_DETAILS"
                }
            },
            "functions": {
                "uid": {
                    "name": "uid",
                    "documentation": "Unique identifier of this `VERSION`, in the form of an `{object_id, a version_tree_id, creating_system_id}` triple, where the `_object_id_` has the same value as the containing `VERSIONED_OBJECT _uid_`.",
                    "is_abstract": true,
                    "result": {
                        "type": "OBJECT_VERSION_ID"
                    }
                },
                "preceding_version_uid": {
                    "name": "preceding_version_uid",
                    "documentation": "Unique identifier of the version of which this version is a modification; Void if this is the first version.",
                    "is_abstract": true,
                    "result": {
                        "type": "OBJECT_VERSION_ID"
                    }
                },
                "data": {
                    "name": "data",
                    "documentation": "The data of this Version.",
                    "is_abstract": true,
                    "result": {
                        "type": "T"
                    }
                },
                "lifecycle_state": {
                    "name": "lifecycle_state",
                    "documentation": "Lifecycle state of this version; coded by openEHR vocabulary `version lifecycle state`.",
                    "is_abstract": true,
                    "result": {
                        "type": "DV_CODED_TEXT"
                    }
                },
                "canonical_form": {
                    "name": "canonical_form",
                    "documentation": "A canonical serial form of this Version, suitable for generating reliable hashes and signatures.",
                    "result": {
                        "type": "String"
                    }
                },
                "owner_id": {
                    "name": "owner_id",
                    "documentation": "Copy of the owning `VERSIONED_OBJECT._uid_` value; extracted from the local `_uid_` property's `_object_id_`.",
                    "post_conditions": {
                        "Post": "Result.value.is_equal (uid.object_id.value)"
                    },
                    "result": {
                        "type": "HIER_OBJECT_ID"
                    }
                },
                "is_branch": {
                    "name": "is_branch",
                    "documentation": "True if this Version represents a branch. Derived from `_uid_` attribute. ",
                    "result": {
                        "type": "Boolean"
                    }
                }
            },
            "invariants": {
                "Owner_id_valid": "owner_id.value.is_equal (uid.object_id.value)",
                "Preceding_version_uid_validity": "uid.version_tree_id.is_first xor preceding_version_uid \/= Void",
                "Lifecycle_state_ valid": "lifecycle_state \/= Void and then terminology (Term_id_openehr).has_code_for_group_id (Group_id_version_lifecycle_state, lifecycle_state.defining_code)"
            }
        },
        "IMPORTED_VERSION": {
            "name": "IMPORTED_VERSION",
            "documentation": "Versions whose content is an `ORIGINAL_VERSION` copied from another location; this class inherits `_commit_audit_` and `_contribution_` from `VERSION<T>`, providing imported versions with their own audit trail and Contribution, distinct from those of the imported `ORIGINAL_VERSION`. ",
            "ancestors": [
                "VERSION"
            ],
            "generic_parameter_defs": {
                "T": {
                    "name": "T"
                }
            },
            "properties": {
                "item": {
                    "name": "item",
                    "documentation": "The `ORIGINAL_VERSION` object that was imported. ",
                    "is_mandatory": true,
                    "type": "ORIGINAL_VERSION"
                }
            },
            "functions": {
                "uid": {
                    "name": "uid",
                    "documentation": "Computed version of inheritance precursor, derived as `_item.uid_`. ",
                    "post_conditions": {
                        "Post": "Result = item.uid"
                    },
                    "result": {
                        "type": "OBJECT_VERSION_ID"
                    }
                },
                "preceding_version_uid": {
                    "name": "preceding_version_uid",
                    "documentation": "Computed version of inheritance precursor, derived as `_item.preceding_version_uid_`. ",
                    "post_conditions": {
                        "Post": "Result = item.preceding_version_uid"
                    },
                    "result": {
                        "type": "OBJECT_VERSION_ID"
                    }
                },
                "lifecycle_state": {
                    "name": "lifecycle_state",
                    "documentation": "Lifecycle state of the content item in wrapped `ORIGINAL_VERSION`, derived as `_item.lifecycle_state_`; coded by openEHR vocabulary `version lifecycle state`.",
                    "result": {
                        "type": "DV_CODED_TEXT"
                    }
                },
                "data": {
                    "name": "data",
                    "documentation": "Original content of this Version. \n",
                    "result": {
                        "type": "T"
                    }
                }
            }
        },
        "ORIGINAL_VERSION": {
            "name": "ORIGINAL_VERSION",
            "documentation": "A Version containing locally created content and optional attestations. ",
            "ancestors": [
                "VERSION"
            ],
            "generic_parameter_defs": {
                "T": {
                    "name": "T"
                }
            },
            "properties": {
                "uid": {
                    "name": "uid",
                    "documentation": "Stored version of inheritance precursor. ",
                    "is_mandatory": true,
                    "type": "OBJECT_VERSION_ID"
                },
                "preceding_version_uid": {
                    "name": "preceding_version_uid",
                    "documentation": "Stored version of inheritance precursor. ",
                    "type": "OBJECT_VERSION_ID"
                },
                "other_input_version_uids": {
                    "_type": "P_BMM_CONTAINER_PROPERTY",
                    "name": "other_input_version_uids",
                    "documentation": "Identifiers of other versions whose content was merged into this version, if any. ",
                    "type_def": {
                        "container_type": "List",
                        "type": "OBJECT_VERSION_ID"
                    },
                    "cardinality": {
                        "lower": 0,
                        "upper_unbounded": true
                    }
                },
                "lifecycle_state": {
                    "name": "lifecycle_state",
                    "documentation": "Lifecycle state of the content item in this version; coded by openEHR vocabulary `version lifecycle state`.",
                    "is_mandatory": true,
                    "type": "DV_CODED_TEXT"
                },
                "attestations": {
                    "_type": "P_BMM_CONTAINER_PROPERTY",
                    "name": "attestations",
                    "documentation": "Set of attestations relating to this version. ",
                    "type_def": {
                        "container_type": "List",
                        "type": "ATTESTATION"
                    },
                    "cardinality": {
                        "lower": 0,
                        "upper_unbounded": true
                    }
                },
                "data": {
                    "name": "data",
                    "documentation": "Data content of this Version.",
                    "type": "T"
                }
            },
            "functions": {
                "is_merged": {
                    "name": "is_merged",
                    "documentation": "True if this Version was created from more than just the preceding (checked out) version.",
                    "result": {
                        "type": "Boolean"
                    }
                }
            },
            "invariants": {
                "Attestations_valid": "attestations \/= Void implies not attestations.is_empty",
                "Is_merged_validity": "other_input_version_ids = Void xor is_merged",
                "Other_input_version_uids_valid": "other_input_version_uids \/= Void implies not other_input_version_uids.is_empty"
            }
        },
        "REVISION_HISTORY_ITEM": {
            "name": "REVISION_HISTORY_ITEM",
            "documentation": "An entry in a revision history, corresponding to a version from a versioned container. Consists of `AUDIT_DETAILS` instances with revision identifier of the revision to which the `AUDIT_DETAILS` instance belongs. ",
            "properties": {
                "version_id": {
                    "name": "version_id",
                    "documentation": "Version identifier for this revision. ",
                    "is_mandatory": true,
                    "type": "OBJECT_VERSION_ID"
                },
                "audits": {
                    "_type": "P_BMM_CONTAINER_PROPERTY",
                    "name": "audits",
                    "documentation": "The audits for this revision; there will always be at least one commit audit (which may itself be an `ATTESTATION`), there may also be further attestations. ",
                    "is_mandatory": true,
                    "type_def": {
                        "container_type": "List",
                        "type": "AUDIT_DETAILS"
                    },
                    "cardinality": {
                        "lower": 1,
                        "upper_unbounded": true
                    }
                }
            },
            "invariants": {
                "Audit_valid": "not audits.is_empty"
            }
        },
        "AUDIT_DETAILS": {
            "name": "AUDIT_DETAILS",
            "documentation": "The set of attributes required to document the committal of an information item to a repository. ",
            "properties": {
                "system_id": {
                    "name": "system_id",
                    "documentation": "Identifier of the logical EHR system where the change was committed. This is almost always owned by the organisation legally responsible for the EHR, and is distinct from any application, or any hosting infrastructure.",
                    "is_mandatory": true,
                    "type": "String"
                },
                "time_committed": {
                    "name": "time_committed",
                    "documentation": "Time of committal of the item. ",
                    "is_mandatory": true,
                    "type": "DV_DATE_TIME"
                },
                "change_type": {
                    "name": "change_type",
                    "documentation": "Type of change. Coded using the openEHR Terminology  audit change type  group.",
                    "is_mandatory": true,
                    "type": "DV_CODED_TEXT"
                },
                "description": {
                    "name": "description",
                    "documentation": "Reason for committal. This may be used to qualify the value in the `_change_type_` field. For example, if the change affects only the EHR directory, this field might be used to indicate 'Folder \"episode 2018-02-16\" added' or similar.",
                    "type": "DV_TEXT"
                },
                "committer": {
                    "name": "committer",
                    "documentation": "Identity and optional reference into identity management service, of user who committed the item. ",
                    "is_mandatory": true,
                    "type": "PARTY_PROXY"
                }
            },
            "invariants": {
                "System_id_valid": "not system_id.is_empty",
                "Change_type_valid": "terminology (Terminology_id_openehr).has_code_for_group_id (Group_id_audit_change_type, change_type.defining_code)"
            }
        },
        "ATTESTATION": {
            "name": "ATTESTATION",
            "documentation": "Record an attestation of a party (the committer) to item(s) of record content. An attestation is an explicit signing by one healthcare agent of particular content for various particular purposes, including:\n\n* for authorisation of a controlled substance or procedure (e.g. sectioning of patient under mental health act); \n* witnessing of content by senior clinical professional; \n* indicating acknowledgement of content by intended recipient, e.g. GP who ordered a test result. \n",
            "ancestors": [
                "AUDIT_DETAILS"
            ],
            "properties": {
                "attested_view": {
                    "name": "attested_view",
                    "documentation": "Optional visual representation of content attested e.g. screen image. ",
                    "type": "DV_MULTIMEDIA"
                },
                "proof": {
                    "name": "proof",
                    "documentation": "Proof of attestation. ",
                    "type": "String"
                },
                "items": {
                    "_type": "P_BMM_CONTAINER_PROPERTY",
                    "name": "items",
                    "documentation": "Items attested, expressed as fully qualified runtime paths to the items in question. Although not recommended, these may include fine-grained items which have been attested in some other system. Otherwise it is assumed to be for the entire VERSION with which it is associated. ",
                    "type_def": {
                        "container_type": "List",
                        "type": "DV_EHR_URI"
                    },
                    "cardinality": {
                        "lower": 0,
                        "upper_unbounded": true
                    }
                },
                "reason": {
                    "name": "reason",
                    "documentation": "Reason of this attestation. Optionally coded by the openEHR Terminology group  attestation reason ; includes values like  authorisation ,  witness  etc. ",
                    "is_mandatory": true,
                    "type": "DV_TEXT"
                },
                "is_pending": {
                    "name": "is_pending",
                    "documentation": "True if this attestation is outstanding; False means it has been completed.",
                    "is_mandatory": true,
                    "type": "Boolean"
                }
            },
            "invariants": {
                "Items_valid": "items \/= Void implies not items.is_empty",
                "Reason_valid": "(reason.generating_type.is_equal (\u201cDV_CODED_TEXT\u201d) implies terminology (Terminology_id_openehr).has_code_for_group_id (Group_id_attestation_reason, reason.defining_code))"
            }
        },
        "PARTICIPATION": {
            "name": "PARTICIPATION",
            "documentation": "Model of a participation of a Party (any Actor or Role) in an activity.  Used to represent any participation of a Party in some activity, which is not  explicitly in the model, e.g. assisting nurse. Can be used to record past or  future participations. \n\nShould not be used in place of more permanent relationships between demographic entities. ",
            "properties": {
                "function": {
                    "name": "function",
                    "documentation": "The function of the Party in this participation (note that a given party might participate in more than one way in a particular activity). This attribute should be coded, but cannot be limited to the HL7v3:ParticipationFunction vocabulary, since it is too limited and hospital-oriented. ",
                    "is_mandatory": true,
                    "type": "DV_TEXT"
                },
                "mode": {
                    "name": "mode",
                    "documentation": "Optional field for recording the 'mode' of the performer \/ activity interaction, e.g. present, by telephone, by email etc. ",
                    "type": "DV_CODED_TEXT"
                },
                "performer": {
                    "name": "performer",
                    "documentation": "The id and possibly demographic system link of the party participating in the activity. ",
                    "is_mandatory": true,
                    "type": "PARTY_PROXY"
                },
                "time": {
                    "_type": "P_BMM_GENERIC_PROPERTY",
                    "name": "time",
                    "documentation": "The time interval during which the participation took place, if it is used in an observational context (i.e. recording facts about the past); or the intended time interval of the participation when used in future contexts, such as EHR Instructions. ",
                    "type_def": {
                        "root_type": "DV_INTERVAL",
                        "generic_parameters": [
                            "DV_DATE_TIME"
                        ]
                    }
                }
            },
            "invariants": {
                "Function_valid": "function.generating_type.is_equal (\"DV_CODED_TEXT\") implies\nterminology (Terminology_id_openehr).has_code_for_group_id (Group_id_participation_function, function.defining_code)",
                "Mode_valid": "mode \/= Void implies terminology (Terminology_id_openehr).has_code_for_group_id (Group_id_participation_mode, mode.defining_code)"
            }
        },
        "PARTY_PROXY": {
            "name": "PARTY_PROXY",
            "documentation": "Abstract concept of a proxy description of a party, including an optional link to data for this party in a demographic or other identity management system. Sub- typed into `PARTY_IDENTIFIED` and `PARTY_SELF`. ",
            "is_abstract": true,
            "properties": {
                "external_ref": {
                    "name": "external_ref",
                    "documentation": "Optional reference to more detailed demographic or identification information for this party, in an external system. ",
                    "type": "PARTY_REF"
                }
            }
        },
        "PARTY_IDENTIFIED": {
            "name": "PARTY_IDENTIFIED",
            "documentation": "Proxy data for an identified party other than the subject of the record, minimally consisting of human-readable identifier(s), such as name, formal (and possibly computable) identifiers such as NHS number, and an optional link to external data. There must be at least one of name, identifier or external_ref present.\n\nUsed to describe parties where only identifiers may be known, and there is no entry at all in the demographic system (or even no demographic system). Typically for health care providers, e.g. name and provider number of an institution. \n\nShould not be used to include patient identifying information. ",
            "ancestors": [
                "PARTY_PROXY"
            ],
            "properties": {
                "name": {
                    "name": "name",
                    "documentation": "Optional human-readable name (in String form).",
                    "type": "String"
                },
                "identifiers": {
                    "_type": "P_BMM_CONTAINER_PROPERTY",
                    "name": "identifiers",
                    "documentation": "One or more formal identifiers (possibly computable). \n",
                    "type_def": {
                        "container_type": "List",
                        "type": "DV_IDENTIFIER"
                    },
                    "cardinality": {
                        "lower": 0,
                        "upper_unbounded": true
                    }
                }
            },
            "invariants": {
                "Basic_validity": "name \/= Void or identifiers \/= Void or external_ref \/= Void",
                "Name_valid": "name \/= Void implies not name.is_empty",
                "Identifiers_valid": "identifiers \/= Void implies not identifiers.is_empty"
            }
        },
        "PARTY_SELF": {
            "name": "PARTY_SELF",
            "documentation": "Party proxy representing the subject of the record. Used to indicate that the party is the owner of the record. May or may not have `_external_ref_` set. ",
            "ancestors": [
                "PARTY_PROXY"
            ]
        },
        "PARTY_RELATED": {
            "name": "PARTY_RELATED",
            "documentation": "Proxy type for identifying a party and its relationship to the subject of the record. Use where the relationship between the party and the subject of the record must be known. ",
            "ancestors": [
                "PARTY_IDENTIFIED"
            ],
            "properties": {
                "relationship": {
                    "name": "relationship",
                    "documentation": "Relationship of subject of this ENTRY to the subject of the record. May be coded. If it is the patient, coded as  self. ",
                    "is_mandatory": true,
                    "type": "DV_CODED_TEXT"
                }
            },
            "invariants": {
                "Relationship_valid": "terminology (Terminology_id_openehr).has_code_for_group_id (Group_id_subject_relationship, relationship.defining_code)"
            }
        },
        "REVISION_HISTORY": {
            "name": "REVISION_HISTORY",
            "documentation": "Purpose Defines the notion of a revision history of audit items, each associated with the version for which that audit was committed. The list is in most-recent-first order. ",
            "properties": {
                "items": {
                    "_type": "P_BMM_CONTAINER_PROPERTY",
                    "name": "items",
                    "documentation": "The items in this history in most-recent-last order. ",
                    "is_mandatory": true,
                    "type_def": {
                        "container_type": "List",
                        "type": "REVISION_HISTORY_ITEM"
                    },
                    "cardinality": {
                        "lower": 1,
                        "upper_unbounded": true
                    }
                }
            },
            "functions": {
                "most_recent_version": {
                    "name": "most_recent_version",
                    "documentation": "The version id of the most recent item, as a String.",
                    "post_conditions": {
                        "Post": "Result.is_equal (items.last.version_id.value)"
                    },
                    "result": {
                        "type": "String"
                    }
                },
                "most_recent_version_time_committed": {
                    "name": "most_recent_version_time_committed",
                    "documentation": "The commit date\/time of the most recent item, as a String. ",
                    "post_conditions": {
                        "Post": "Result.is_equal (items.last.audits.first. time_committed.value)"
                    },
                    "result": {
                        "type": "String"
                    }
                }
            }
        },
        "VERSIONED_FOLDER": {
            "name": "VERSIONED_FOLDER",
            "documentation": "A version-controlled hierarchy of `FOLDERs` giving the effect of a directory. ",
            "ancestors": [
                "VERSIONED_OBJECT"
            ]
        },
        "FOLDER": {
            "name": "FOLDER",
            "documentation": "The concept of a named folder.\n\nNOTE: It is strongly recommended that the inherited attribute `_uid_` be populated in _top-level_ (i.e. tree-root) `FOLDER` objects, using the UID copied from the `_object_id()_` of the `_uid_` field of the enclosing `VERSION` object. +\nFor example, the `ORIGINAL_VERSION.uid` `87284370-2D4B-4e3d-A3F3-F303D2F4F34B::uk.nhs.ehr1::2`  would be copied to the `_uid_` field of the top `FOLDER` object.",
            "ancestors": [
                "LOCATABLE"
            ],
            "properties": {
                "items": {
                    "_type": "P_BMM_CONTAINER_PROPERTY",
                    "name": "items",
                    "documentation": "The list of references to other (usually) versioned objects logically in this folder. ",
                    "type_def": {
                        "container_type": "List",
                        "type": "OBJECT_REF"
                    },
                    "cardinality": {
                        "lower": 0,
                        "upper_unbounded": true
                    }
                },
                "folders": {
                    "_type": "P_BMM_CONTAINER_PROPERTY",
                    "name": "folders",
                    "documentation": "Sub-folders of this `FOLDER`. ",
                    "type_def": {
                        "container_type": "List",
                        "type": "FOLDER"
                    },
                    "cardinality": {
                        "lower": 0,
                        "upper_unbounded": true
                    }
                },
                "details": {
                    "name": "details",
                    "documentation": "Archetypable meta-data for `FOLDER`.",
                    "type": "ITEM_STRUCTURE"
                }
            },
            "invariants": {
                "Folders_valid": "not folders.is_empty"
            }
        },
        "AUTHORED_RESOURCE": {
            "name": "AUTHORED_RESOURCE",
            "documentation": "Abstract idea of an online resource created by a human author. \n",
            "is_abstract": true,
            "properties": {
                "original_language": {
                    "name": "original_language",
                    "documentation": "Language in which this resource was initially authored. Although there is no language primacy of resources overall, the language of original authoring is required to ensure natural language translations can preserve quality. Language is relevant in both the description and ontology sections. ",
                    "is_mandatory": true,
                    "type": "CODE_PHRASE"
                },
                "is_controlled": {
                    "name": "is_controlled",
                    "documentation": "True if this resource is under any kind of change control (even file copying), in which case revision history is created. ",
                    "type": "Boolean"
                },
                "translations": {
                    "_type": "P_BMM_GENERIC_PROPERTY",
                    "name": "translations",
                    "documentation": "List of details for each natural-language translation made of this resource, keyed by language. For each translation listed here, there must be corresponding sections in all language-dependent parts of the resource. The `_original_language_` does not appear in this list.",
                    "type_def": {
                        "root_type": "Hash",
                        "generic_parameters": [
                            "String",
                            "TRANSLATION_DETAILS"
                        ]
                    }
                },
                "description": {
                    "name": "description",
                    "documentation": "Description and lifecycle information of the resource.",
                    "type": "RESOURCE_DESCRIPTION"
                },
                "revision_history": {
                    "name": "revision_history",
                    "documentation": "The revision history of the resource. Only required if `_is_controlled_ = True` (avoids large revision histories for informal or private editing situations). ",
                    "type": "REVISION_HISTORY"
                }
            },
            "functions": {
                "current_revision": {
                    "name": "current_revision",
                    "documentation": "Most recent revision in `_revision_history_` if `_is_controlled_` else  (uncontrolled) . ",
                    "post_conditions": {
                        "Post": "Result = revision_history.most_recent_version"
                    },
                    "result": {
                        "type": "String"
                    }
                },
                "languages_available": {
                    "name": "languages_available",
                    "documentation": "Total list of languages available in this resource, derived from `_original_language_` and `_translations_`.\n",
                    "result": {
                        "_type": "P_BMM_CONTAINER_TYPE",
                        "container_type": "List",
                        "type": "String"
                    }
                }
            },
            "invariants": {
                "Original_language_valid": "code_set (Code_set_id_languages).has_code (original_language.as_string)",
                "Languages_available_valid": "languages_available.has (original_language)",
                "Revision_history_valid": "is_controlled xor revision_history = Void",
                "Current_revision_valid": "(current_revision \/= Void and not is_controlled) implies current_revision.is_equal (\u201c(uncontrolled)\u201d)",
                "Translations_valid": "translations \/= Void implies (not translations.is_empty and not translations.has (orginal_language.code_string))",
                "Description_valid": "translations \/= Void implies (description.details.for_all (d |\ntranslations.has_key (d.language.code_string)))"
            }
        },
        "RESOURCE_DESCRIPTION": {
            "name": "RESOURCE_DESCRIPTION",
            "documentation": "Defines the descriptive meta-data of a resource.",
            "properties": {
                "original_author": {
                    "_type": "P_BMM_GENERIC_PROPERTY",
                    "name": "original_author",
                    "documentation": "Original author of this resource, with all relevant details, including organisation.",
                    "is_mandatory": true,
                    "type_def": {
                        "root_type": "Hash",
                        "generic_parameters": [
                            "String",
                            "String"
                        ]
                    }
                },
                "other_contributors": {
                    "_type": "P_BMM_CONTAINER_PROPERTY",
                    "name": "other_contributors",
                    "documentation": "Other contributors to the resource, probably listed in  `'name <email>'`  form. ",
                    "type_def": {
                        "container_type": "List",
                        "type": "String"
                    },
                    "cardinality": {
                        "lower": 0,
                        "upper_unbounded": true
                    }
                },
                "lifecycle_state": {
                    "name": "lifecycle_state",
                    "documentation": "Lifecycle state of the resource, typically including states such as: `initial | submitted | experimental | awaiting_approval | approved | superseded | obsolete`.",
                    "is_mandatory": true,
                    "type": "String"
                },
                "resource_package_uri": {
                    "name": "resource_package_uri",
                    "documentation": "URI of package to which this resource belongs.",
                    "type": "String"
                },
                "other_details": {
                    "_type": "P_BMM_GENERIC_PROPERTY",
                    "name": "other_details",
                    "documentation": "Additional non language-senstive resource meta-data, as a list of name\/value pairs. ",
                    "type_def": {
                        "root_type": "Hash",
                        "generic_parameters": [
                            "String",
                            "String"
                        ]
                    }
                },
                "parent_resource": {
                    "name": "parent_resource",
                    "documentation": "Reference to owning resource. ",
                    "is_mandatory": true,
                    "type": "AUTHORED_RESOURCE"
                },
                "details": {
                    "_type": "P_BMM_GENERIC_PROPERTY",
                    "name": "details",
                    "documentation": "Details of all parts of resource description that are natural language-dependent, keyed by language code. ",
                    "is_mandatory": true,
                    "type_def": {
                        "root_type": "Hash",
                        "generic_parameters": [
                            "String",
                            "RESOURCE_DESCRIPTION_ITEM"
                        ]
                    }
                }
            },
            "invariants": {
                "Original_author_valid": "not original_author.is_empty",
                "Lifecycle_state_valid": "not lifecycle_state.is_empty",
                "Details_valid": "not details.is_empty",
                "Language_valid": "parent_resource \/= Void implies details.for_all (d | parent_resource.languages_available.has (d.language.code_string))",
                "Parent_resource_valid": "parent_resource \/= Void implies parent_resource.description = self"
            }
        },
        "TRANSLATION_DETAILS": {
            "name": "TRANSLATION_DETAILS",
            "documentation": "Class providing details of a natural language translation. ",
            "properties": {
                "language": {
                    "name": "language",
                    "documentation": "Language of the translation.",
                    "is_mandatory": true,
                    "type": "CODE_PHRASE"
                },
                "author": {
                    "_type": "P_BMM_GENERIC_PROPERTY",
                    "name": "author",
                    "documentation": "Translator name and other demographic details.",
                    "is_mandatory": true,
                    "type_def": {
                        "root_type": "Hash",
                        "generic_parameters": [
                            "String",
                            "String"
                        ]
                    }
                },
                "accreditaton": {
                    "name": "accreditaton",
                    "documentation": "Accreditation of translator, usually a national translator's registration or association membership id.",
                    "type": "String"
                },
                "other_details": {
                    "_type": "P_BMM_GENERIC_PROPERTY",
                    "name": "other_details",
                    "documentation": "Any other meta-data.",
                    "type_def": {
                        "root_type": "Hash",
                        "generic_parameters": [
                            "String",
                            "String"
                        ]
                    }
                }
            },
            "invariants": {
                "Language_valid": "code_set (Code_set_id_languages).has_code (language)"
            }
        },
        "RESOURCE_DESCRIPTION_ITEM": {
            "name": "RESOURCE_DESCRIPTION_ITEM",
            "documentation": "Language-specific detail of resource description. When a resource is translated for use in another language environment, each `RESOURCE_DESCRIPTION_ITEM` needs to be copied and translated into the new language.",
            "properties": {
                "language": {
                    "name": "language",
                    "documentation": "The localised language in which the items in this description item are written. Coded from openEHR code set `languages`.",
                    "is_mandatory": true,
                    "type": "CODE_PHRASE"
                },
                "purpose": {
                    "name": "purpose",
                    "documentation": "Purpose of the resource.",
                    "is_mandatory": true,
                    "type": "String"
                },
                "keywords": {
                    "_type": "P_BMM_CONTAINER_PROPERTY",
                    "name": "keywords",
                    "documentation": "Keywords which characterise this resource, used e.g. for indexing and searching. ",
                    "type_def": {
                        "container_type": "List",
                        "type": "String"
                    },
                    "cardinality": {
                        "lower": 0,
                        "upper_unbounded": true
                    }
                },
                "use": {
                    "name": "use",
                    "documentation": "Description of the uses of the resource, i.e. contexts in which it could be used. \n",
                    "type": "String"
                },
                "misuse": {
                    "name": "misuse",
                    "documentation": "Description of any misuses of the resource, i.e. contexts in which it should not be used.",
                    "type": "String"
                },
                "copyright": {
                    "name": "copyright",
                    "documentation": "Optional copyright statement for the resource as a knowledge resource. \n",
                    "type": "String"
                },
                "original_resource_uri": {
                    "_type": "P_BMM_GENERIC_PROPERTY",
                    "name": "original_resource_uri",
                    "documentation": "URIs of original clinical document(s) or description of which resource is a formalisation, in the language of this description item; keyed by meaning. ",
                    "type_def": {
                        "root_type": "Hash",
                        "generic_parameters": [
                            "String",
                            "String"
                        ]
                    }
                },
                "other_details": {
                    "_type": "P_BMM_GENERIC_PROPERTY",
                    "name": "other_details",
                    "documentation": "Additional language-senstive resource metadata, as a list of name\/value pairs. ",
                    "type_def": {
                        "root_type": "Hash",
                        "generic_parameters": [
                            "String",
                            "String"
                        ]
                    }
                }
            },
            "invariants": {
                "Language_valid": "code_set (Code_set_id_languages).has_code (language)",
                "Purpose_valid": "not purpose.is_empty",
                "Use_valid": "use \/= Void implies not use.is_empty",
                "misuse_valid": "misuse \/= Void implies not misuse.is_empty",
                "copyright_valid": "copyright \/= Void implies not copyright.is_empty"
            }
        },
        "ITEM_TAG": {
            "name": "ITEM_TAG",
            "documentation": "A tag with optional value that is associated with a target information entity identified by a UID.",
            "properties": {
                "key": {
                    "name": "key",
                    "documentation": "The tag key. May not be empty or contain leading or trailing whitespace.",
                    "is_mandatory": true,
                    "type": "String"
                },
                "value": {
                    "name": "value",
                    "documentation": "The value. If set, may not be empty.",
                    "type": "String"
                },
                "target": {
                    "name": "target",
                    "documentation": "Identifier of target, which may be a `VERSIONED_OBJECT<T>` or a `VERSION<T>`.",
                    "is_mandatory": true,
                    "type": "UID_BASED_ID"
                },
                "target_path": {
                    "name": "target_path",
                    "documentation": "Optional archetype (i.e. AQL) or RM path within `_target_`, used to tag a fine-grained element.",
                    "type": "String"
                },
                "owner_id": {
                    "name": "owner_id",
                    "documentation": "Identifier of owner object, such as EHR.",
                    "is_mandatory": true,
                    "type": "OBJECT_REF"
                }
            },
            "invariants": {
                "Inv_key_valid": "not key.is_empty and key.is_justified",
                "Inv_value_valid": "value \/= Void implies not value.is_empty"
            }
        },
        "DATA_STRUCTURE": {
            "name": "DATA_STRUCTURE",
            "documentation": "Abstract parent class of all data structure types. Includes the `_as_hierarchy_` function which can generate the equivalent CEN EN13606 single hierarchy for each subtype's physical representation. For example, the physical representation of an `ITEM_LIST` is `List<ELEMENT>`; its implementation of `_as_hierarchy_` will generate a `CLUSTER` containing the set of `ELEMENT` nodes from the list. ",
            "is_abstract": true,
            "ancestors": [
                "LOCATABLE"
            ],
            "functions": {
                "as_hierarchy": {
                    "name": "as_hierarchy",
                    "documentation": "Hierarchical equivalent of the physical representation of each subtype, compatible with CEN EN 13606 structures. ",
                    "result": {
                        "type": "ITEM"
                    }
                }
            }
        },
        "ITEM_STRUCTURE": {
            "name": "ITEM_STRUCTURE",
            "documentation": "Abstract parent class of all spatial data types. ",
            "is_abstract": true,
            "ancestors": [
                "DATA_STRUCTURE"
            ]
        },
        "ITEM_TREE": {
            "name": "ITEM_TREE",
            "documentation": "Logical tree data structure. The tree may be empty. Used for representing data which are logically a tree such as audiology results, microbiology results, biochemistry results.",
            "ancestors": [
                "ITEM_STRUCTURE"
            ],
            "properties": {
                "items": {
                    "_type": "P_BMM_CONTAINER_PROPERTY",
                    "name": "items",
                    "documentation": "The items comprising the `ITEM_TREE`. Can include 0 or more `CLUSTERs` and\/or 0 or more individual `ELEMENTs`.",
                    "type_def": {
                        "container_type": "List",
                        "type": "ITEM"
                    },
                    "cardinality": {
                        "lower": 0,
                        "upper_unbounded": true
                    }
                }
            },
            "functions": {
                "has_element_path": {
                    "name": "has_element_path",
                    "documentation": "True if path  a_path' is a valid leaf path.\n",
                    "parameters": {
                        "a_path": {
                            "name": "a_path",
                            "type": "String"
                        }
                    },
                    "result": {
                        "type": "Boolean"
                    }
                },
                "element_at_path": {
                    "name": "element_at_path",
                    "documentation": "Return the leaf element at the path  a_path'.",
                    "parameters": {
                        "a_path": {
                            "name": "a_path",
                            "type": "String"
                        }
                    },
                    "result": {
                        "type": "ELEMENT"
                    }
                },
                "as_hierarchy": {
                    "name": "as_hierarchy",
                    "documentation": "Generate a CEN EN13606-compatible hierarchy, which is the same as the tree's physical representation.",
                    "result": {
                        "type": "CLUSTER"
                    }
                }
            }
        },
        "ITEM_SINGLE": {
            "name": "ITEM_SINGLE",
            "documentation": "Logical single value data structure. Used to represent any data which is logically a single value, such as a person's height or weight.",
            "ancestors": [
                "ITEM_STRUCTURE"
            ],
            "properties": {
                "item": {
                    "name": "item",
                    "is_mandatory": true,
                    "type": "ELEMENT"
                }
            },
            "functions": {
                "as_hierarchy": {
                    "name": "as_hierarchy",
                    "documentation": "Generate a CEN EN13606-compatible hierarchy consisting of a single `ELEMENT`.",
                    "result": {
                        "type": "ELEMENT"
                    }
                }
            }
        },
        "ITEM_TABLE": {
            "name": "ITEM_TABLE",
            "documentation": "Logical relational database style table data structure, in which columns are named and ordered with respect to each other. Implemented using Cluster-per-row encoding. Each row Cluster must have an identical number of Elements, each of which in turn must have identical names and value types in the corresponding positions in each row. \n\nSome columns may be designated  key' columns, containing key data for each row, in the manner of relational tables. This allows row-naming, where each row represents a body site, a blood antigen etc. All values in a column have the same data type. \n\nUsed for representing any data which is logically a table of values, such as blood pressure, most protocols, many blood tests etc. \n\nMisuse: Not to be used for time-based data, which should be represented with the temporal class `HISTORY`. The table may be empty. ",
            "ancestors": [
                "ITEM_STRUCTURE"
            ],
            "properties": {
                "rows": {
                    "_type": "P_BMM_CONTAINER_PROPERTY",
                    "name": "rows",
                    "documentation": "Physical representation of the table as a list of `CLUSTERs`, each containing the data of one row of the table. ",
                    "type_def": {
                        "container_type": "List",
                        "type": "CLUSTER"
                    },
                    "cardinality": {
                        "lower": 0,
                        "upper_unbounded": true
                    }
                }
            },
            "functions": {
                "row_count": {
                    "name": "row_count",
                    "documentation": "Number of rows in the table.",
                    "result": {
                        "type": "Integer"
                    }
                },
                "column_count": {
                    "name": "column_count",
                    "documentation": "Return number of columns in the table.",
                    "result": {
                        "type": "Integer"
                    }
                },
                "row_names": {
                    "name": "row_names",
                    "documentation": "Return set of row names.",
                    "result": {
                        "_type": "P_BMM_CONTAINER_TYPE",
                        "container_type": "List",
                        "type": "DV_TEXT"
                    },
                    "is_nullable": true
                },
                "column_names": {
                    "name": "column_names",
                    "documentation": "Return set of column names.",
                    "result": {
                        "_type": "P_BMM_CONTAINER_TYPE",
                        "container_type": "List",
                        "type": "DV_TEXT"
                    },
                    "is_nullable": true
                },
                "ith_row": {
                    "name": "ith_row",
                    "documentation": "Return i-th row.",
                    "parameters": {
                        "i": {
                            "name": "i",
                            "type": "Integer"
                        }
                    },
                    "result": {
                        "type": "CLUSTER"
                    }
                },
                "has_row_with_name": {
                    "name": "has_row_with_name",
                    "documentation": "Return `True` if there is a column with name = `_a_key_`.",
                    "parameters": {
                        "a_key": {
                            "name": "a_key",
                            "type": "String"
                        }
                    },
                    "result": {
                        "type": "Boolean"
                    }
                },
                "has_column_with_name": {
                    "name": "has_column_with_name",
                    "documentation": "Return `True` if there is a column with name = `_a_key_`.",
                    "parameters": {
                        "a_key": {
                            "name": "a_key",
                            "type": "String"
                        }
                    },
                    "result": {
                        "type": "Boolean"
                    }
                },
                "named_row": {
                    "name": "named_row",
                    "documentation": "Return row with name = `_a_key_`.",
                    "parameters": {
                        "a_key": {
                            "name": "a_key",
                            "type": "String"
                        }
                    },
                    "result": {
                        "type": "CLUSTER"
                    }
                },
                "has_row_with_key": {
                    "name": "has_row_with_key",
                    "documentation": "Return `True` if there is a row with key `_keys_`.",
                    "parameters": {
                        "keys": {
                            "_type": "P_BMM_CONTAINER_FUNCTION_PARAMETER",
                            "name": "keys",
                            "is_nullable": true,
                            "type_def": {
                                "container_type": "List",
                                "type": "String"
                            },
                            "cardinality": {
                                "lower": 0,
                                "upper_unbounded": true
                            }
                        }
                    },
                    "result": {
                        "type": "Boolean"
                    }
                },
                "row_with_key": {
                    "name": "row_with_key",
                    "documentation": "Return rows with particular keys.",
                    "parameters": {
                        "keys": {
                            "_type": "P_BMM_CONTAINER_FUNCTION_PARAMETER",
                            "name": "keys",
                            "is_nullable": true,
                            "type_def": {
                                "container_type": "List",
                                "type": "String"
                            },
                            "cardinality": {
                                "lower": 0,
                                "upper_unbounded": true
                            }
                        }
                    },
                    "result": {
                        "type": "CLUSTER"
                    }
                },
                "element_at_cell_ij": {
                    "name": "element_at_cell_ij",
                    "documentation": "Return cell at a particular location.",
                    "parameters": {
                        "i": {
                            "name": "i",
                            "type": "Integer"
                        },
                        "j": {
                            "name": "j",
                            "type": "Integer"
                        }
                    },
                    "result": {
                        "type": "ELEMENT"
                    }
                },
                "as_hierarchy": {
                    "name": "as_hierarchy",
                    "documentation": "Generate a CEN EN13606-compatible hierarchy consisting of a single `CLUSTER` containing the `CLUSTERs` representing the columns of this table. ",
                    "result": {
                        "type": "CLUSTER"
                    }
                }
            },
            "invariants": {
                "Valid_structure": "rows.for_all (items.for_all (instance_of (\"ELEMENT\")))"
            }
        },
        "ITEM_LIST": {
            "name": "ITEM_LIST",
            "documentation": "Logical list data structure, where each item has a value and can be referred to by a name and a positional index in the list. The list may be empty. \n\n`ITEM_LIST` is used to represent any data which is logically a list of values, such as blood pressure, most protocols, many blood tests etc. \n\nNot to be used for time-based lists, which should be represented with the proper temporal class, i.e. `HISTORY`.",
            "ancestors": [
                "ITEM_STRUCTURE"
            ],
            "properties": {
                "items": {
                    "_type": "P_BMM_CONTAINER_PROPERTY",
                    "name": "items",
                    "documentation": "Physical representation of the list. ",
                    "type_def": {
                        "container_type": "List",
                        "type": "ELEMENT"
                    },
                    "cardinality": {
                        "lower": 0,
                        "upper_unbounded": true
                    }
                }
            },
            "functions": {
                "item_count": {
                    "name": "item_count",
                    "documentation": "Count of all items.",
                    "result": {
                        "type": "Integer"
                    }
                },
                "names": {
                    "name": "names",
                    "documentation": "Retrieve the names of all items.",
                    "result": {
                        "_type": "P_BMM_CONTAINER_TYPE",
                        "container_type": "List",
                        "type": "DV_TEXT"
                    },
                    "is_nullable": true
                },
                "named_item": {
                    "name": "named_item",
                    "documentation": "Retrieve the item with name \u2018a_name\u2019.",
                    "parameters": {
                        "a_name": {
                            "name": "a_name",
                            "type": "String"
                        }
                    },
                    "result": {
                        "type": "ELEMENT"
                    }
                },
                "ith_item": {
                    "name": "ith_item",
                    "documentation": "Retrieve the i-th item with name.",
                    "parameters": {
                        "i": {
                            "name": "i",
                            "type": "Integer"
                        }
                    },
                    "result": {
                        "type": "ELEMENT"
                    }
                },
                "as_hierarchy": {
                    "name": "as_hierarchy",
                    "documentation": "Generate a CEN EN13606-compatible hierarchy consisting of a single `CLUSTER` containing the `ELEMENTs` of this list.",
                    "result": {
                        "type": "CLUSTER"
                    }
                }
            },
            "invariants": {
                "Valid_structure": " items.forall (i:ITEM | i.type = \"ELEMENT\")"
            }
        },
        "EVENT": {
            "name": "EVENT",
            "documentation": "Defines the abstract notion of a single event in a series. This class is generic, allowing types to be generated which are locked to particular spatial types, such as `EVENT<ITEM_LIST>`. Subtypes express point or intveral data. ",
            "is_abstract": true,
            "ancestors": [
                "LOCATABLE"
            ],
            "generic_parameter_defs": {
                "T": {
                    "name": "T",
                    "conforms_to_type": "ITEM_STRUCTURE"
                }
            },
            "properties": {
                "time": {
                    "name": "time",
                    "documentation": "Time of this event. If the width is non-zero, it is the time point of the trailing edge of the event. ",
                    "is_mandatory": true,
                    "type": "DV_DATE_TIME"
                },
                "state": {
                    "name": "state",
                    "documentation": "Optional state data for this event.",
                    "type": "ITEM_STRUCTURE"
                },
                "data": {
                    "_type": "P_BMM_SINGLE_PROPERTY_OPEN",
                    "name": "data",
                    "documentation": "The data of this event.",
                    "is_mandatory": true,
                    "type": "T"
                }
            },
            "functions": {
                "offset": {
                    "name": "offset",
                    "documentation": "Offset of this event from origin, computed as time.diff(parent.origin).",
                    "post_conditions": {
                        "Post_condition": "Result = time.diff(parent.origin)"
                    },
                    "result": {
                        "type": "DV_DURATION"
                    }
                }
            },
            "invariants": {
                "Offset_validity": "",
                "Offset_validity1": "offset \/= Void and then offset = time.diff (parent.origin)"
            }
        },
        "POINT_EVENT": {
            "name": "POINT_EVENT",
            "documentation": "Defines a single point event in a series.",
            "ancestors": [
                "EVENT"
            ],
            "generic_parameter_defs": {
                "T": {
                    "name": "T"
                }
            }
        },
        "INTERVAL_EVENT": {
            "name": "INTERVAL_EVENT",
            "documentation": "Defines a single interval event in a series. ",
            "ancestors": [
                "EVENT"
            ],
            "generic_parameter_defs": {
                "T": {
                    "name": "T"
                }
            },
            "properties": {
                "width": {
                    "name": "width",
                    "documentation": "Duration of the time interval during which the values recorded under `data` are true and, if set, the values recorded under `state` are true. Void if an instantaneous event.",
                    "is_mandatory": true,
                    "type": "DV_DURATION"
                },
                "sample_count": {
                    "name": "sample_count",
                    "documentation": "Optional count of original samples to which this event corresponds.",
                    "type": "Integer"
                },
                "math_function": {
                    "name": "math_function",
                    "documentation": "Mathematical function of the data of this event, e.g.  maximum, mean etc. Coded using https:\/\/github.com\/openEHR\/terminology\/blob\/master\/openEHR_RM\/en\/openehr_terminology.xml[openEHR vocabulary `event math function`]. Default value `640|actual|`, meaning 'actual value'.",
                    "is_mandatory": true,
                    "type": "DV_CODED_TEXT"
                }
            },
            "functions": {
                "interval_start_time": {
                    "name": "interval_start_time",
                    "documentation": "Start time of the interval of this event.",
                    "result": {
                        "type": "DV_DATE_TIME"
                    }
                }
            },
            "invariants": {
                "Math_function_validity": "terminology (Terminology_id_openehr).has_code_for_group_id (Group_id_event_math_function, math_function.defining_code)",
                "Interval_start_time_valid": "interval_start_time = time - width"
            }
        },
        "HISTORY": {
            "name": "HISTORY",
            "documentation": "Root object of a linear history, i.e. time series structure. This is a generic class whose type parameter must be a descendant of `ITEM_STRUCTURE`, ensuring that each Event in the `_events_` of a given instance is of the same structural type, i.e. `ITEM_TREE`, `ITEM_LIST` etc.\n\nFor a periodic series of events, period will be set, and the time of each Event in the History must correspond; i.e. the `EVENT._offset_` must be a multiple of period for each Event. Missing events in a period History are however allowed. ",
            "ancestors": [
                "DATA_STRUCTURE"
            ],
            "generic_parameter_defs": {
                "T": {
                    "name": "T",
                    "conforms_to_type": "ITEM_STRUCTURE"
                }
            },
            "properties": {
                "origin": {
                    "name": "origin",
                    "documentation": "Time origin of this event history. The first event is not necessarily at the origin point. ",
                    "is_mandatory": true,
                    "type": "DV_DATE_TIME"
                },
                "period": {
                    "name": "period",
                    "documentation": "Period between samples in this segment if periodic.",
                    "type": "DV_DURATION"
                },
                "duration": {
                    "name": "duration",
                    "documentation": "Duration of the entire History; either corresponds to the duration of all the events, and\/or the duration represented by the summary, if it exists. ",
                    "type": "DV_DURATION"
                },
                "summary": {
                    "name": "summary",
                    "documentation": "Optional summary data that aggregates, organizes, reduces and transforms the event series. This may be a text or image that presents a graphical presentation, or some data that assists with the interpretation of the data.",
                    "type": "ITEM_STRUCTURE"
                },
                "events": {
                    "_type": "P_BMM_CONTAINER_PROPERTY",
                    "name": "events",
                    "documentation": "The events in the series. This attribute is of a generic type whose parameter must be a descendant of `ITEM_SUTRUCTURE`.",
                    "type_def": {
                        "container_type": "List",
                        "type_def": {
                            "_type": "P_BMM_GENERIC_TYPE",
                            "root_type": "EVENT",
                            "generic_parameters": [
                                "T"
                            ]
                        }
                    },
                    "cardinality": {
                        "lower": 0,
                        "upper_unbounded": true
                    }
                }
            },
            "functions": {
                "is_periodic": {
                    "name": "is_periodic",
                    "documentation": "Indicates whether history is periodic. \n",
                    "result": {
                        "type": "Boolean"
                    }
                }
            },
            "invariants": {
                "Events_valid": "(events \/= Void and then not events.is_empty) or summary \/= Void",
                "Periodic_validity": "is_periodic xor period = Void",
                "Period_consistency": "is_periodic implies events.for_all (e: EVENT | e.offset. to_seconds.mod(period.to_seconds) = 0)"
            }
        },
        "ITEM": {
            "name": "ITEM",
            "documentation": "The abstract parent of `CLUSTER` and `ELEMENT` representation classes. ",
            "is_abstract": true,
            "ancestors": [
                "LOCATABLE"
            ]
        },
        "CLUSTER": {
            "name": "CLUSTER",
            "documentation": "The grouping variant of `ITEM`, which may contain further instances of `ITEM`, in an ordered list. ",
            "ancestors": [
                "ITEM"
            ],
            "properties": {
                "items": {
                    "_type": "P_BMM_CONTAINER_PROPERTY",
                    "name": "items",
                    "documentation": "Ordered list of items - `CLUSTER` or `ELEMENT` objects - under this `CLUSTER`. ",
                    "is_mandatory": true,
                    "type_def": {
                        "container_type": "List",
                        "type": "ITEM"
                    },
                    "cardinality": {
                        "lower": 1,
                        "upper_unbounded": true
                    }
                }
            }
        },
        "ELEMENT": {
            "name": "ELEMENT",
            "documentation": "The leaf variant of `ITEM`, to which a `DATA_VALUE` instance is attached. ",
            "ancestors": [
                "ITEM"
            ],
            "properties": {
                "null_flavour": {
                    "name": "null_flavour",
                    "documentation": "Flavour of null value, e.g. `253|unknown|`, `271|no information|`, `272|masked|`, and `273|not applicable|`.",
                    "type": "DV_CODED_TEXT"
                },
                "value": {
                    "name": "value",
                    "documentation": "Property representing leaf value object of `ELEMENT`. In real data, any concrete subtype of `DATA_VALUE` can be used.",
                    "type": "DATA_VALUE"
                },
                "null_reason": {
                    "name": "null_reason",
                    "documentation": "Optional specific reason for null value; if set, `_null_flavour_` must be set. Null reason may apply only to a minority of clinical data, commonly needed in reporting contexts.",
                    "type": "DV_TEXT"
                }
            },
            "functions": {
                "is_null": {
                    "name": "is_null",
                    "documentation": "True if value logically not known, e.g. if indeterminate, not asked etc. ",
                    "result": {
                        "type": "Boolean"
                    }
                }
            },
            "invariants": {
                "Inv_is_null_valid": "is_null() = (value = Void)",
                "Inv_null_flavour_indicated": "is_null() xor null_flavour = Void",
                "Inv_null_flavour_valid": "is_null implies terminology (Terminology_id_openehr).has_code_for_group_id (Group_id_null_flavour, null_flavour.defining_code)",
                "Inv_null_reason_valid": "null_reason \/= Void implies is_null()"
            }
        },
        "DATA_VALUE": {
            "name": "DATA_VALUE",
            "documentation": "Abstract parent of all `DV_` data value types.",
            "is_abstract": true,
            "ancestors": [
                "OPENEHR_DEFINITIONS"
            ]
        },
        "DV_BOOLEAN": {
            "name": "DV_BOOLEAN",
            "documentation": "Items which are truly boolean data, such as true\/false or yes\/no answers. For such data, it is important to devise the meanings (usually questions in subjective data)  carefully, so that the only allowed results are in fact true or false. \n\nMisuse: The DV_BOOLEAN class should not be used as a replacement for naively modelled enumerated types such as male\/female etc. Such values should be coded, and in any case the enumeration often has more than two values. \n",
            "ancestors": [
                "DATA_VALUE"
            ],
            "properties": {
                "value": {
                    "name": "value",
                    "documentation": "Boolean value of this item. Actual values may be language or implementation dependent.",
                    "is_mandatory": true,
                    "type": "Boolean"
                }
            }
        },
        "DV_STATE": {
            "name": "DV_STATE",
            "documentation": "For representing state values which obey a defined state machine, such as a variable  representing the states of an instruction or care process. \n\nDV_STATE is expressed as a String but its values are driven by archetype-defined  state machines. This provides a powerful way of capturing stateful complex processes  in simple data. \n",
            "ancestors": [
                "DATA_VALUE"
            ],
            "properties": {
                "value": {
                    "name": "value",
                    "documentation": "The state name. State names are determined by a state\/event table defined in archetypes, and coded using openEHR Terminology or local archetype terms, as specified by the archetype. ",
                    "is_mandatory": true,
                    "type": "DV_CODED_TEXT"
                },
                "is_terminal": {
                    "name": "is_terminal",
                    "documentation": "Indicates whether this state is a terminal state, such as  \"aborted\",  \"completed\" etc. from which no further transitions are possible.",
                    "is_mandatory": true,
                    "type": "Boolean"
                }
            }
        },
        "DV_IDENTIFIER": {
            "name": "DV_IDENTIFIER",
            "documentation": "Type for representing identifiers of real-world entities. Typical identifiers include drivers licence number, social security number, veterans affairs number, prescription id, order id, and so on.\n\nDV_IDENTIFIER is used to represent any identifier of a real thing, issued by some authority or agency. \n\nMisuse: DV_IDENTIFIER is not used to express identifiers generated by the infrastructure to refer to information items; the types OBJECT_ID and OBJECT_REF and subtypes are defined for this purpose.",
            "ancestors": [
                "DATA_VALUE"
            ],
            "properties": {
                "issuer": {
                    "name": "issuer",
                    "documentation": "Optional authority which issues the kind of id used in the id field of this object. ",
                    "type": "String"
                },
                "assigner": {
                    "name": "assigner",
                    "documentation": "Optional organisation that assigned the id to the item being identified.",
                    "type": "String"
                },
                "id": {
                    "name": "id",
                    "documentation": "The identifier value. Often structured, according to the definition of the issuing authority's rules. ",
                    "is_mandatory": true,
                    "type": "String"
                },
                "type": {
                    "name": "type",
                    "documentation": "Optional identifier type, such as  prescription , or  Social Security Number . One day a controlled vocabulary might be possible for this.",
                    "type": "String"
                }
            },
            "invariants": {
                "Issuer_valid": "not issuer.is_empty",
                "Assigner_valid": "not assigner.is_empty",
                "Id_valid": "not id.is_empty",
                "Type_valid": "not type.is_empty"
            }
        },
        "DV_ENCAPSULATED": {
            "name": "DV_ENCAPSULATED",
            "documentation": "Abstract class defining the common meta-data of all types of encapsulated data.",
            "is_abstract": true,
            "ancestors": [
                "DATA_VALUE"
            ],
            "properties": {
                "charset": {
                    "name": "charset",
                    "documentation": "Name of character encoding scheme in which this value is encoded. Coded from openEHR Code Set  character sets . Unicode is the default assumption in openEHR, with UTF-8 being the assumed encoding. This attribute allows for variations from these assumptions. ",
                    "type": "CODE_PHRASE"
                },
                "language": {
                    "name": "language",
                    "documentation": "Optional indicator of the localised language in which the data is written, if relevant. Coded from openEHR Code Set `languages`.",
                    "type": "CODE_PHRASE"
                }
            },
            "invariants": {
                "Size_valid": "size >= 0",
                "Language_valid": "language \/= Void implies code_set (Code_set_id_languages).has_code (language)",
                "Charset_valid": "charset \/= Void implies code_set (Code_set_id_character_sets).has_code (charset)"
            }
        },
        "DV_MULTIMEDIA": {
            "name": "DV_MULTIMEDIA",
            "documentation": "A specialisation of `DV_ENCAPSULATED` for audiovisual and bio-signal types. Includes further metadata relating to multimedia types which are not applicable to other subtypes of `DV_ENCAPSULATED`.",
            "ancestors": [
                "DV_ENCAPSULATED"
            ],
            "properties": {
                "alternate_text": {
                    "name": "alternate_text",
                    "documentation": "Text to display in lieu of multimedia display\/replay.",
                    "type": "String"
                },
                "uri": {
                    "name": "uri",
                    "documentation": "URI reference to electronic information stored outside the record as a file, database entry etc, if supplied as a reference. \n",
                    "type": "DV_URI"
                },
                "data": {
                    "_type": "P_BMM_CONTAINER_PROPERTY",
                    "name": "data",
                    "documentation": "The actual data found at `_uri_`, if supplied inline.",
                    "type_def": {
                        "container_type": "Array",
                        "type": "Octet"
                    },
                    "cardinality": {
                        "lower": 0,
                        "upper_unbounded": true
                    }
                },
                "media_type": {
                    "name": "media_type",
                    "documentation": "Data media type coded from openEHR code set  media types  (interface for the IANA MIME types code set). \n",
                    "is_mandatory": true,
                    "type": "CODE_PHRASE"
                },
                "compression_algorithm": {
                    "name": "compression_algorithm",
                    "documentation": "Compression type, a coded value from the openEHR Integrity check code set. Void means no compression. ",
                    "type": "CODE_PHRASE"
                },
                "integrity_check": {
                    "_type": "P_BMM_CONTAINER_PROPERTY",
                    "name": "integrity_check",
                    "documentation": "Binary cryptographic integrity checksum.",
                    "type_def": {
                        "container_type": "Array",
                        "type": "Octet"
                    },
                    "cardinality": {
                        "lower": 0,
                        "upper_unbounded": true
                    }
                },
                "integrity_check_algorithm": {
                    "name": "integrity_check_algorithm",
                    "documentation": "Type of integrity check, a coded value from the openEHR `Integrity check` code set. ",
                    "type": "CODE_PHRASE"
                },
                "thumbnail": {
                    "name": "thumbnail",
                    "documentation": "The thumbnail for this item, if one exists; mainly for graphics formats.",
                    "type": "DV_MULTIMEDIA"
                },
                "size": {
                    "name": "size",
                    "documentation": "Original size in bytes of unencoded encapsulated data. I.e. encodings such as base64, hexadecimal etc do not change the value of this attribute.",
                    "is_mandatory": true,
                    "type": "Integer"
                }
            },
            "functions": {
                "is_external": {
                    "name": "is_external",
                    "documentation": "Computed from the value of the `_uri_` attribute: True if  the data is stored externally to the record, as indicated by `_uri_`. A copy may also be stored internally, in which case `_is_expanded_` is also true.",
                    "result": {
                        "type": "Boolean"
                    }
                },
                "is_inline": {
                    "name": "is_inline",
                    "documentation": "Computed from the value of the data attribute. True if  the  data is stored  in  expanded  form, ie within the EHR itself. ",
                    "result": {
                        "type": "Boolean"
                    }
                },
                "is_compressed": {
                    "name": "is_compressed",
                    "documentation": "Computed from the value of the `_compression_algorithm_` attribute: True if  the  data is stored in compressed form. ",
                    "result": {
                        "type": "Boolean"
                    }
                },
                "has_integrity_check": {
                    "name": "has_integrity_check",
                    "documentation": "Computed from the value of the `_integrity_check_algorithm_` attribute: True if an integrity check has been computed. ",
                    "result": {
                        "type": "Boolean"
                    }
                }
            },
            "invariants": {
                "Not_empty": "is_inline or is_external",
                "Media_type_valid": "media_type \/= Void and then code_set (Code_set_id_media_types).has_code (media_type)",
                "Compression_algorithm_validity": "compression_algorithm \/= Void implies code_set (Code_set_id_compression_algorithms).has_code (compression_algorithm)",
                "Integrity_check_validity": "integrity_check \/= Void implies integrity_check_algorithm \/= Void",
                "Integrity_check_algorithm_validity": "integrity_check_algorithm \/= Void implies code_set (Code_set_id_integrity_check_algorithms).has_code (integrity_check_algorithm)",
                "Size_valid": "size >= 0"
            }
        },
        "DV_PARSABLE": {
            "name": "DV_PARSABLE",
            "documentation": "Encapsulated data expressed as a parsable String. The internal model of the data item is not described in the openEHR model in common with other encapsulated types, but in this case, the form of the data is assumed to be plaintext, rather than compressed or other types of large binary data. ",
            "ancestors": [
                "DV_ENCAPSULATED"
            ],
            "properties": {
                "value": {
                    "name": "value",
                    "documentation": "The string, which may validly be empty in some syntaxes.",
                    "is_mandatory": true,
                    "type": "String"
                },
                "formalism": {
                    "name": "formalism",
                    "documentation": "Name of the formalism, e.g.  GLIF 1.0 ,  Proforma  etc.",
                    "is_mandatory": true,
                    "type": "String"
                }
            },
            "functions": {
                "size": {
                    "name": "size",
                    "documentation": "Size in bytes of value.",
                    "result": {
                        "type": "Integer"
                    }
                }
            },
            "invariants": {
                "Formalism_valid": "not formalism.is_empty",
                "Size_valid": "size >= 0"
            }
        },
        "DV_PARAGRAPH": {
            "name": "DV_PARAGRAPH",
            "documentation": "DEPRECATED: use markdown formatted `DV_TEXT` instead.\n\nOriginal definition:\n\nA logical composite text value consisting of a series of `DV_TEXTs`, i.e. plain text (optionally coded) potentially with simple formatting, to form a larger tract of prose, which may be interpreted for display purposes as a paragraph. \n\n`DV_PARAGRAPH` is the standard way for constructing longer text items in summaries, reports and so on. ",
            "ancestors": [
                "DATA_VALUE"
            ],
            "properties": {
                "items": {
                    "_type": "P_BMM_CONTAINER_PROPERTY",
                    "name": "items",
                    "documentation": "Items making up the paragraph, each of which is a text item (which may have its own formatting, and\/or have hyperlinks). ",
                    "is_mandatory": true,
                    "type_def": {
                        "container_type": "List",
                        "type": "DV_TEXT"
                    },
                    "cardinality": {
                        "lower": 1,
                        "upper_unbounded": true
                    }
                }
            },
            "invariants": {
                "Items_valid": "not items.is_empty"
            }
        },
        "DV_TEXT": {
            "name": "DV_TEXT",
            "documentation": "A text item, which may contain any amount of legal characters arranged as e.g. words, sentences etc (i.e. one `DV_TEXT` may be more than one word). Visual formatting and hyperlinks may be included via markdown.\n\nIf the `_formatting_` field is set, the `_value_` field is affected as follows:\n\n* `_formatting_ = \"plain\"`: plain text, may contain newlines;\n* `_formatting_ = \"plain_no_newlines\"`: plain text with no newlines;\n* `_formatting_ = \"markdown\"`: text in markdown format; use of CommonMark strongly recommended.\n\nA `DV_TEXT` can be coded by adding mappings to it.",
            "ancestors": [
                "DATA_VALUE"
            ],
            "properties": {
                "value": {
                    "name": "value",
                    "documentation": "Displayable rendition of the item, regardless of its underlying structure. For `DV_CODED_TEXT`, this is the rubric of the complete term as provided by the terminology service.\n",
                    "is_mandatory": true,
                    "type": "String"
                },
                "hyperlink": {
                    "name": "hyperlink",
                    "documentation": "DEPRECATED: this field is deprecated; use markdown link\/text in the `_value_` attribute, and `\"markdown\"` as the value of the `_formatting_` field.\n\nOriginal usage, prior to RM Release 1.0.4: Optional link sitting behind a section of plain text or coded term item.",
                    "type": "DV_URI"
                },
                "formatting": {
                    "name": "formatting",
                    "documentation": "If set, contains one of the following values:\n\n* `\"plain\"`: use for plain text, possibly containing newlines, but otherwise unformatted (same as Void);\n* `\"plain_no_newlines\"`: use for text containing no newlines or other formatting;\n* `\"markdown\"`: use for markdown formatted text, strongly recommended in the format of the CommonMark specification.\n\nDEPRECATED usage: contains a string of the form `\"name:value; name:value...\"` , e.g. `\"font-weight : bold; font-family : Arial; font-size : 12pt;\"`. Values taken from W3C CSS2 properties lists for background and font . ",
                    "type": "String"
                },
                "mappings": {
                    "_type": "P_BMM_CONTAINER_PROPERTY",
                    "name": "mappings",
                    "documentation": "Terms from other terminologies most closely matching this term, typically used where the originator (e.g. pathology lab) of information uses a local terminology but also supplies one or more equivalents from well known terminologies (e.g. LOINC). \n",
                    "type_def": {
                        "container_type": "List",
                        "type": "TERM_MAPPING"
                    },
                    "cardinality": {
                        "lower": 0,
                        "upper_unbounded": true
                    }
                },
                "language": {
                    "name": "language",
                    "documentation": "Optional indicator of the localised language in which the value is written. Coded from openEHR Code Set  languages . Only used when either the text object is in a different language from the enclosing `ENTRY`, or else the text object is being used outside of an `ENTRY` or other enclosing structure which indicates the language. ",
                    "type": "CODE_PHRASE"
                },
                "encoding": {
                    "name": "encoding",
                    "documentation": "Name of character encoding scheme in which this value is encoded. Coded from openEHR Code Set  character sets . Unicode is the default assumption in openEHR, with UTF-8 being the assumed encoding. This attribute allows for variations from these assumptions. \n",
                    "type": "CODE_PHRASE"
                }
            },
            "invariants": {
                "Valid_value": "not value.is_empty",
                "Language_valid": "language \/= Void implies code_set (Code_set_id_languages).has_code (language)",
                "Encoding_valid": "encoding \/= Void implies code_set (Code_set_id_character_sets).has_code (encoding)",
                "Mappings_valid": "mappings \/= void implies not mappings.is_empty",
                "Formatting_valid": "formatting \/= void implies not formatting.is_empty"
            }
        },
        "DV_CODED_TEXT": {
            "name": "DV_CODED_TEXT",
            "documentation": "A text item whose value must be the rubric from a controlled terminology, the key (i.e. the 'code') of which is the `_defining_code_` attribute. In other words: a `DV_CODED_TEXT` is a combination of a `CODE_PHRASE` (effectively a code) and the rubric of that term, from a terminology service, in the language in which the data were authored. \n\nSince `DV_CODED_TEXT` is a subtype of `DV_TEXT`, it can be used in place of it, effectively allowing the type `DV_TEXT` to mean  a text item, which may optionally be coded. \n\nMisuse: If the intention is to represent a term code attached in some way to a fragment of plain text, `DV_CODED_TEXT` should not be used; instead use a `DV_TEXT` and a `TERM_MAPPING` to a `CODE_PHRASE`. ",
            "ancestors": [
                "DV_TEXT"
            ],
            "properties": {
                "defining_code": {
                    "name": "defining_code",
                    "documentation": "The term of which the  `_value_` attribute is the textual rendition (i.e. rubric). \n",
                    "is_mandatory": true,
                    "type": "CODE_PHRASE"
                }
            }
        },
        "TERM_MAPPING": {
            "name": "TERM_MAPPING",
            "documentation": "Represents a coded term mapped to a `DV_TEXT`, and the relative match of the target term with respect to the mapped item. Plain or coded text items may appear in the EHR for which one or mappings in alternative terminologies are required. Mappings are only used to enable computer processing, so they can only be instances of `DV_CODED_TEXT`.\n\nUsed for adding classification terms (e.g. adding ICD classifiers to SNOMED descriptive terms), or mapping into equivalents in other terminologies (e.g. across nursing vocabularies). \n",
            "properties": {
                "match": {
                    "name": "match",
                    "documentation": "The relative match of the target term with respect to the mapped text item. Result meanings: \n\n* `'>'`: the mapping is to a broader term e.g. orginal text =  arbovirus infection , target =  viral infection  \n* `'='`: the mapping is to a (supposedly) equivalent to the original item \n* `'<'`: the mapping is to a narrower term. e.g. original text =  diabetes , mapping =  diabetes mellitus . \n* `'?'`: the kind of mapping is unknown. \n\nThe first three values are taken from the ISO standards 2788 ( Guide to Establishment and development of monolingual thesauri) and 5964 (Guide to Establishment and development of multilingual thesauri). \n",
                    "is_mandatory": true,
                    "type": "Character"
                },
                "purpose": {
                    "name": "purpose",
                    "documentation": "Purpose of the mapping e.g. 'automated data mining', 'billing', 'interoperability'.",
                    "type": "DV_CODED_TEXT"
                },
                "target": {
                    "name": "target",
                    "documentation": "The target term of the mapping. ",
                    "is_mandatory": true,
                    "type": "CODE_PHRASE"
                }
            },
            "functions": {
                "narrower": {
                    "name": "narrower",
                    "documentation": "The mapping is to a narrower term.",
                    "post_conditions": {
                        "Post": "match = \u2018<\u2019 implies Result"
                    },
                    "result": {
                        "type": "Boolean"
                    }
                },
                "broader": {
                    "name": "broader",
                    "documentation": "The mapping is to a broader term.",
                    "post_conditions": {
                        "Post": "match = \u2018>\u2019 implies Result"
                    },
                    "result": {
                        "type": "Boolean"
                    }
                },
                "equivalent": {
                    "name": "equivalent",
                    "documentation": "The mapping is to an equivalent term.",
                    "result": {
                        "type": "Boolean"
                    }
                },
                "unknown": {
                    "name": "unknown",
                    "documentation": "The kind of mapping is unknown.",
                    "post_conditions": {
                        "Post": "match = \u2018?\u2019 implies Result"
                    },
                    "result": {
                        "type": "Boolean"
                    }
                },
                "is_valid_match_code": {
                    "name": "is_valid_match_code",
                    "documentation": "True if match valid.",
                    "parameters": {
                        "c": {
                            "name": "c",
                            "type": "Character"
                        }
                    },
                    "post_conditions": {
                        "Post": "Result := c = \u2018>\u2019 or c = \u2018=\u2019 or c = \u2018<\u2019 or c = \u2018?\u2019"
                    },
                    "result": {
                        "type": "Boolean"
                    }
                }
            },
            "invariants": {
                "Purpose_valid": "purpose \/= Void implies terminology (Terminology_id_openehr).has_code_for_group_id (Group_id_term_mapping_purpose, purpose.defining_code)",
                "Match_valid": "is_valid_match_code (match)"
            }
        },
        "CODE_PHRASE": {
            "name": "CODE_PHRASE",
            "documentation": "A fully coordinated (i.e. all coordination has been performed) term from a terminology service (as distinct from a particular terminology). ",
            "properties": {
                "terminology_id": {
                    "name": "terminology_id",
                    "documentation": "Identifier of the distinct terminology from which the code_string (or its elements) was extracted.",
                    "is_mandatory": true,
                    "type": "TERMINOLOGY_ID"
                },
                "code_string": {
                    "name": "code_string",
                    "documentation": "The key used by the terminology service to identify a concept or coordination of concepts. This string is most likely parsable inside the terminology service, but nothing can be assumed about its syntax outside that context. ",
                    "is_mandatory": true,
                    "type": "String"
                },
                "preferred_term": {
                    "name": "preferred_term",
                    "documentation": "Optional attribute to carry preferred term corresponding to the code or expression in `_code_string_`. Typical use in integration situations which create mappings, and representing data for which both a (non-preferred) actual term and a preferred term are both required.",
                    "type": "String"
                }
            },
            "invariants": {
                "Code_string_valid": "not code_string.is_empty"
            }
        },
        "DV_ORDERED": {
            "name": "DV_ORDERED",
            "documentation": "Abstract class defining the concept of ordered values, which includes ordinals as well as true quantities. It defines the functions  `<` and `_is_strictly_comparable_to()_`, the latter of which must evaluate to `True` for instances being compared with the  `<` function, or used as limits in the `DV_INTERVAL<T>` class. \n\nData value types which are to be used as limits in the `DV_INTERVAL<T>` class must inherit from this class, and implement the function `_is_strictly_comparable_to()_` to ensure that instances compare meaningfully. For example, instances of `DV_QUANTITY` can only be compared if they measure the same kind of physical quantity. \n",
            "is_abstract": true,
            "ancestors": [
                "DATA_VALUE",
                "Ordered"
            ],
            "properties": {
                "normal_status": {
                    "name": "normal_status",
                    "documentation": "Optional normal status indicator of value with respect to normal range for this value. Often included by lab, even if the normal range itself is not included. Coded by ordinals in series HHH, HH, H, (nothing), L, LL, LLL; see openEHR terminology group  `normal_status`. ",
                    "type": "CODE_PHRASE"
                },
                "normal_range": {
                    "name": "normal_range",
                    "documentation": "Optional normal range. ",
                    "type": "DV_INTERVAL"
                },
                "other_reference_ranges": {
                    "_type": "P_BMM_CONTAINER_PROPERTY",
                    "name": "other_reference_ranges",
                    "documentation": "Optional tagged other reference ranges for this value in its particular measurement context.",
                    "type_def": {
                        "container_type": "List",
                        "type_def": {
                            "_type": "P_BMM_GENERIC_TYPE",
                            "root_type": "REFERENCE_RANGE",
                            "generic_parameters": [
                                "DV_ORDERED"
                            ]
                        }
                    },
                    "cardinality": {
                        "lower": 0,
                        "upper_unbounded": true
                    }
                }
            },
            "functions": {
                "is_strictly_comparable_to": {
                    "name": "is_strictly_comparable_to",
                    "documentation": "Test if two instances are strictly comparable. Effected in descendants.",
                    "is_abstract": true,
                    "parameters": {
                        "other": {
                            "name": "other",
                            "type": "DV_ORDERED"
                        }
                    },
                    "result": {
                        "type": "Boolean"
                    }
                },
                "is_simple": {
                    "name": "is_simple",
                    "documentation": "True if this quantity has no reference ranges.",
                    "result": {
                        "type": "Boolean"
                    }
                },
                "is_normal": {
                    "name": "is_normal",
                    "documentation": "Value is in the normal range, determined by comparison of the value to `_normal_range_` if present, or by the `_normal_status_` marker if present. \n",
                    "pre_conditions": {
                        "Pre": "normal_range \/= Void or normal_status \/= Void"
                    },
                    "post_conditions": {
                        "Post_range": "normal_range \/= Void implies Result = normal_range.has (self)",
                        "Post_status": "normal_status \/= Void implies normal_status.code_string.is_equal (\u201cN\u201d)"
                    },
                    "result": {
                        "type": "Boolean"
                    }
                },
                "less_than": {
                    "name": "less_than",
                    "documentation": "True if this Ordered object is less than `_other_`. Redefined in descendants.",
                    "is_abstract": true,
                    "parameters": {
                        "other": {
                            "name": "other",
                            "type": "DV_ORDERED"
                        }
                    },
                    "result": {
                        "type": "Boolean"
                    }
                }
            },
            "invariants": {
                "Other_reference_ranges_validity": "other_reference_ranges \/= Void implies not other_reference_ranges.is_empty",
                "Is_simple_validity": "(normal_range = Void and other_reference_ranges = Void) implies is_simple",
                "Normal_status_validity": "normal_status \/= Void implies code_set (Code_set_id_normal_statuses).has_code (normal_status)",
                "Normal_range_and_status_consistency": "(normal_range \/= Void and normal_status \/= Void) implies (normal_status.code_string.is_equal (\u201cN\u201d) xor not normal_range.has (self))"
            }
        },
        "DV_INTERVAL": {
            "name": "DV_INTERVAL",
            "documentation": "Generic class defining an interval (i.e. range) of a comparable type. An interval is a contiguous subrange of a comparable base type. Used to define intervals of dates, times, quantities (whose units match) and so on. The type parameter, `T`, must be a descendant of the type `DV_ORDERED`, which is necessary (but not sufficient) for instances to be compared (`_strictly_comparable_` is also needed). \n\nWithout the `DV_INTERVAL` class, quite a few more `DV_` classes would be needed to express logical intervals, namely interval versions of all the date\/time classes, and of quantity classes. Further, it allows the semantics of intervals to be stated in one place unequivocally, including the conditions for strict comparison. \n\nThe basic semantics are derived from the class `Interval<T>`, described in the support RM. ",
            "ancestors": [
                "DATA_VALUE",
                "Interval"
            ],
            "generic_parameter_defs": {
                "T": {
                    "name": "T",
                    "conforms_to_type": "DV_ORDERED"
                }
            },
            "invariants": {
                "Limits_consistent": "(not upper_unbounded and not lower_unbounded) implies (lower.is_strictly_comparable_to(upper) and lower <= upper)"
            }
        },
        "REFERENCE_RANGE": {
            "name": "REFERENCE_RANGE",
            "documentation": "Defines a named range to be associated with any `DV_ORDERED` datum. Each such range is particular to the patient and context, e.g. sex, age, and any other factor which affects ranges. May be used to represent normal, therapeutic, dangerous, critical etc ranges.",
            "generic_parameter_defs": {
                "T": {
                    "name": "T",
                    "conforms_to_type": "DV_ORDERED"
                }
            },
            "properties": {
                "meaning": {
                    "name": "meaning",
                    "documentation": "Term whose value indicates the meaning of this range, e.g.  normal,  critical,  therapeutic  etc.",
                    "is_mandatory": true,
                    "type": "DV_TEXT"
                },
                "range": {
                    "name": "range",
                    "documentation": "The data range for this meaning, e.g. critical  etc.",
                    "is_mandatory": true,
                    "type": "DV_INTERVAL"
                }
            },
            "functions": {
                "is_in_range": {
                    "name": "is_in_range",
                    "documentation": "Indicates if the value  `_v_` is inside the range.\n",
                    "parameters": {
                        "v": {
                            "name": "v",
                            "type": "DV_ORDERED"
                        }
                    },
                    "result": {
                        "type": "Boolean"
                    }
                }
            },
            "invariants": {
                "Range_is_simple": "(range.lower_unbounded or else range.lower.is_simple) and (range.upper_unbounded or else range.upper.is_simple)"
            }
        },
        "DV_QUANTIFIED": {
            "name": "DV_QUANTIFIED",
            "documentation": "Abstract class defining the concept of true quantified values, i.e. values which are not only ordered, but which have a precise magnitude.",
            "is_abstract": true,
            "ancestors": [
                "DV_ORDERED"
            ],
            "properties": {
                "magnitude_status": {
                    "name": "magnitude_status",
                    "documentation": "Optional status of magnitude with values: \n\n* `\"=\"`   :   magnitude is a point value \n* `\"<\"`   :   value is < magnitude \n* `\">\"`   :   value is > magnitude \n* `\"<=\"` : value is <= magnitude \n* `\">=\"` : value is >= magnitude \n* `\"~\"`   :   value is approximately magnitude \n\nIf not present, assumed meaning is  `\"=\"` . \n",
                    "type": "String"
                },
                "accuracy": {
                    "name": "accuracy",
                    "documentation": "Accuracy of measurement. Exact form of expression determined in descendants.",
                    "type": "Any"
                }
            },
            "functions": {
                "valid_magnitude_status": {
                    "name": "valid_magnitude_status",
                    "documentation": "Test whether a string value is one of the valid values for the magnitude_status attribute. ",
                    "post_conditions": {
                        "Post": "Result = s in {\"=\", \"<\", \">\", \"<=\", \">=\", \"~\"}"
                    },
                    "result": {
                        "type": "Boolean"
                    }
                },
                "magnitude": {
                    "name": "magnitude",
                    "is_abstract": true,
                    "result": {
                        "type": "Ordered_Numeric"
                    }
                },
                "accuracy_unknown": {
                    "name": "accuracy_unknown",
                    "documentation": "True if accuracy is not known, e.g. due to not being recorded or discernable.",
                    "result": {
                        "type": "Boolean"
                    }
                },
                "is_equal": {
                    "name": "is_equal",
                    "documentation": "Return True if this `DV_QUANTIFIED` is considered equal to `_other_`.",
                    "is_abstract": true,
                    "parameters": {
                        "other": {
                            "name": "other",
                            "type": "DV_QUANTIFIED"
                        }
                    },
                    "result": {
                        "type": "Boolean"
                    }
                },
                "less_than": {
                    "name": "less_than",
                    "documentation": "True if this Quantified object is less than `_other_`, based on comparison of `_magnitude_`.",
                    "parameters": {
                        "other": {
                            "name": "other",
                            "type": "DV_QUANTIFIED"
                        }
                    },
                    "pre_conditions": {
                        "Pre_comparable": "is_strictly_comparable()"
                    },
                    "post_conditions": {
                        "Post_result": "Result = magnitude < other.magnitude"
                    },
                    "result": {
                        "type": "Boolean"
                    }
                }
            },
            "invariants": {
                "Magnitude_status_valid": "magnitude_status \/= Void implies valid_magnitude_status (magnitude_status)"
            }
        },
        "DV_PROPORTION": {
            "name": "DV_PROPORTION",
            "documentation": "Models a ratio of values, i.e. where the numerator and denominator are both pure numbers. The `_valid_proportion_kind_` property of the `PROPORTION_KIND` class is used to control the type attribute to be one of a defined set.\n\nUsed for recording titers (e.g. 1:128), concentration ratios, e.g. Na:K (unitary denominator), albumin:creatinine ratio, and percentages, e.g. red cell distirbution width (RDW). \n \nMisuse: Should not be used to represent things like blood pressure which are often written using a  '\/' character, giving the misleading impression that the item is a ratio, when in fact it is a structured value. Similarly, visual acuity, often written as (e.g.) \"6\/24\" in clinical notes is not a ratio but an ordinal (which includes non-numeric symbols like CF = count fingers etc). Should not be used for formulations. ",
            "ancestors": [
                "PROPORTION_KIND",
                "DV_AMOUNT"
            ],
            "properties": {
                "numerator": {
                    "name": "numerator",
                    "documentation": "Numerator of ratio",
                    "is_mandatory": true,
                    "type": "Real"
                },
                "denominator": {
                    "name": "denominator",
                    "documentation": "Denominator of ratio.",
                    "is_mandatory": true,
                    "type": "Real"
                },
                "type": {
                    "name": "type",
                    "documentation": "Indicates semantic type of proportion, including percent, unitary etc.",
                    "is_mandatory": true,
                    "type": "Integer"
                },
                "precision": {
                    "name": "precision",
                    "documentation": "Precision  to  which  the  `_numerator_` and `_denominator_` values of  the  proportion are expressed, in terms of number  of decimal places. The value 0 implies an integral quantity. The value -1 implies no limit, i.e. any number of decimal places. ",
                    "type": "Integer"
                },
                "normal_range": {
                    "_type": "P_BMM_GENERIC_PROPERTY",
                    "name": "normal_range",
                    "documentation": "Optional normal range. ",
                    "type_def": {
                        "root_type": "DV_INTERVAL",
                        "generic_parameters": [
                            "DV_PROPORTION"
                        ]
                    }
                },
                "other_reference_ranges": {
                    "_type": "P_BMM_CONTAINER_PROPERTY",
                    "name": "other_reference_ranges",
                    "documentation": "Optional tagged other reference ranges for this value in its particular measurement context.",
                    "type_def": {
                        "container_type": "List",
                        "type_def": {
                            "_type": "P_BMM_GENERIC_TYPE",
                            "root_type": "REFERENCE_RANGE",
                            "generic_parameters": [
                                "DV_PROPORTION"
                            ]
                        }
                    },
                    "cardinality": {
                        "lower": 0,
                        "upper_unbounded": true
                    }
                }
            },
            "functions": {
                "magnitude": {
                    "name": "magnitude",
                    "documentation": "Effective magnitude represented by ratio.",
                    "result": {
                        "type": "Real"
                    }
                },
                "is_integral": {
                    "name": "is_integral",
                    "documentation": "True if the `_numerator_` and `_denominator_` values are integers, i.e. if `_precision_` is 0.",
                    "result": {
                        "type": "Boolean"
                    }
                },
                "add": {
                    "name": "add",
                    "documentation": "Sum of two strictly comparable proportions.",
                    "parameters": {
                        "other": {
                            "name": "other",
                            "type": "DV_PROPORTION"
                        }
                    },
                    "result": {
                        "type": "DV_PROPORTION"
                    }
                },
                "subtract": {
                    "name": "subtract",
                    "documentation": "Difference between two strictly comparable proportions.",
                    "parameters": {
                        "other": {
                            "name": "other",
                            "type": "DV_PROPORTION"
                        }
                    },
                    "result": {
                        "type": "DV_PROPORTION"
                    }
                },
                "is_equal": {
                    "name": "is_equal",
                    "documentation": "Return True if this `DV_AMOUNT` is considered equal to `_other_`.",
                    "parameters": {
                        "other": {
                            "name": "other",
                            "type": "DV_PROPORTION"
                        }
                    },
                    "result": {
                        "type": "Boolean"
                    }
                },
                "multiply": {
                    "name": "multiply",
                    "documentation": "Product of this Proportion and `_factor_`.",
                    "parameters": {
                        "factor": {
                            "name": "factor",
                            "type": "Real"
                        }
                    },
                    "result": {
                        "type": "DV_PROPORTION"
                    }
                },
                "less_than": {
                    "name": "less_than",
                    "documentation": "True if this Proportion is less than  `_other_`. Only valid if `_is_strictly_comparable_to()_` is True.",
                    "parameters": {
                        "other": {
                            "name": "other",
                            "type": "DV_PROPORTION"
                        }
                    },
                    "pre_conditions": {
                        "Pre_comparable": "is_strictly_comparable()"
                    },
                    "post_conditions": {
                        "Post_result": "Result = magnitude < other.magnitude"
                    },
                    "result": {
                        "type": "Boolean"
                    }
                },
                "is_strictly_comparable_to": {
                    "name": "is_strictly_comparable_to",
                    "documentation": "Return True if the `_type_` of this proportion is the same as the `_type_` of `_other_`.",
                    "parameters": {
                        "other": {
                            "name": "other",
                            "type": "DV_ORDERED"
                        }
                    },
                    "result": {
                        "type": "Boolean"
                    }
                }
            },
            "invariants": {
                "Type_validity": "valid_proportion_kind (type)",
                "Precision_validity": "precision = 0 implies is_integral",
                "Is_integral_validity": "is_integral implies (numerator.floor = numerator and denominator.floor = denominator)",
                "Fraction_validity": "(type = pk_fraction or type = pk_integer_fraction) implies is_integral",
                "Unitary_validity": "type = pk_unitary implies denominator = 1",
                "Percent_validity": "type = pk_percent implies denominator = 100",
                "Valid_denominator": "denominator \/= 0.0"
            }
        },
        "PROPORTION_KIND": {
            "_type": "P_BMM_ENUMERATION_INTEGER",
            "name": "PROPORTION_KIND",
            "documentation": "Class of enumeration constants defining types of proportion for the `DV_PROPORTION` class. ",
            "ancestors": [
                "Integer"
            ],
            "item_names": [
                "pk_ratio",
                "pk_unitary",
                "pk_percent",
                "pk_fraction",
                "pk_integer_fraction"
            ],
            "item_values": [
                0,
                1,
                2,
                3,
                4
            ],
            "item_documentations": [
                "Ratio type. Numerator and denominator may be any value.\n",
                "Denominator must be 1.",
                "Denominator is 100, numerator is understood as a percentage value.",
                "Numerator and denominator are integral, and the presentation method uses a slash, e.g.  1\/2 . \n",
                "Numerator and denominator are integral, and the presentation method uses a slash, e.g.  1\/2 ; if the numerator is greater than the denominator, e.g. n=3, d=2, the presentation is  1 1\/2 ."
            ]
        },
        "DV_AMOUNT": {
            "name": "DV_AMOUNT",
            "documentation": "Abstract class defining the concept of relative quantified  'amounts'. For relative quantities, the  `+` and  `-` operators are defined (unlike descendants of `DV_ABSOLUTE_QUANTITY`, such as the date\/time types). \n",
            "is_abstract": true,
            "ancestors": [
                "DV_QUANTIFIED"
            ],
            "properties": {
                "accuracy_is_percent": {
                    "name": "accuracy_is_percent",
                    "documentation": "If `True`, indicates that when this object was created, `_accuracy_` was recorded as a percent value; if `False`, as an absolute quantity value.",
                    "type": "Boolean"
                },
                "accuracy": {
                    "name": "accuracy",
                    "documentation": "Accuracy of measurement, expressed either as a half-range percent value (`_accuracy_is_percent_` = `True`) or a half-range quantity. A value of `0` means that accuracy is 100%, i.e. no error.\n\nA value of `_unknown_accuracy_value_` means that accuracy was not recorded.",
                    "type": "Real"
                }
            },
            "functions": {
                "valid_percentage": {
                    "name": "valid_percentage",
                    "documentation": "Test whether a number is a valid percentage, i.e. between 0 and 100. ",
                    "parameters": {
                        "number": {
                            "name": "number",
                            "type": "Ordered_Numeric"
                        }
                    },
                    "result": {
                        "type": "Boolean"
                    }
                },
                "add": {
                    "name": "add",
                    "documentation": "Sum of this amount and another. The value of accuracy in the result is either:\n\n* the sum of the accuracies of the operands, if both present, or;\n* both operand accuracies are unknown_accuracy_value.\n\nIf the accuracy value is a percentage in one operand and not in the other, the form in the result is that of the larger operand.",
                    "parameters": {
                        "other": {
                            "name": "other",
                            "type": "DV_AMOUNT"
                        }
                    },
                    "pre_conditions": {
                        "Pre_comparable": "is_strictly_comparable_to (other)"
                    },
                    "result": {
                        "type": "DV_AMOUNT"
                    }
                },
                "subtract": {
                    "name": "subtract",
                    "documentation": "Difference of this amount and another. The value of `_accuracy_` in the result is either:\n\n* the sum of the accuracies of the operands, if both present, or;\n* unknown, if either or both operand accuracies are unknown.\n\nIf the `_accuracy_` value is a percentage in one operand and not in the other, the form in the result is that of the larger operand.",
                    "parameters": {
                        "other": {
                            "name": "other",
                            "type": "DV_AMOUNT"
                        }
                    },
                    "result": {
                        "type": "DV_AMOUNT"
                    }
                },
                "is_equal": {
                    "name": "is_equal",
                    "documentation": "Return True if this `DV_AMOUNT` is considered equal to `_other_`.",
                    "is_abstract": true,
                    "parameters": {
                        "other": {
                            "name": "other",
                            "type": "DV_AMOUNT"
                        }
                    },
                    "result": {
                        "type": "Boolean"
                    }
                },
                "multiply": {
                    "name": "multiply",
                    "documentation": "Product of this Amount and `_factor_`.",
                    "parameters": {
                        "factor": {
                            "name": "factor",
                            "type": "Real"
                        }
                    },
                    "result": {
                        "type": "DV_AMOUNT"
                    }
                },
                "negative": {
                    "name": "negative",
                    "documentation": "Negated version of current object, such as used for representing a difference, e.g. a weight loss.",
                    "result": {
                        "type": "DV_AMOUNT"
                    }
                },
                "less_than": {
                    "name": "less_than",
                    "documentation": "True if this object is less than `_other_`. Based on comparison of `_magnitude_`.",
                    "parameters": {
                        "other": {
                            "name": "other",
                            "type": "DV_AMOUNT"
                        }
                    },
                    "pre_conditions": {
                        "Pre_comparable": "is_strictly_comparable()"
                    },
                    "post_conditions": {
                        "Post_result": "Result = magnitude < other.magnitude"
                    },
                    "result": {
                        "type": "Boolean"
                    }
                }
            },
            "invariants": {
                "Accuracy_is_percent_validity": "accuracy = 0 implies not accuracy_is_percent",
                "Accuracy_validity": "accuracy_is_percent implies valid_percentage (accuracy)"
            }
        },
        "DV_QUANTITY": {
            "name": "DV_QUANTITY",
            "documentation": "Quantitified type representing  scientific  quantities, i.e. quantities expressed as a magnitude and units. Units are expressed in the UCUM syntax (http:\/\/unitsofmeasure.org\/ucum.html[Unified Code for Units of Measure (UCUM)], by Gunther Schadow and Clement J. McDonald of The Regenstrief Institute)  (case-sensitive form) by default, or another system if `_units_system_` is set. \n\nCan also be used for time durations, where it is more convenient to treat these as simply a number of seconds rather than days, months, years (in the latter case, `DV_DURATION` may be used).",
            "ancestors": [
                "DV_AMOUNT"
            ],
            "properties": {
                "magnitude": {
                    "name": "magnitude",
                    "documentation": "Numeric magnitude of the quantity.",
                    "is_mandatory": true,
                    "type": "Real"
                },
                "precision": {
                    "name": "precision",
                    "documentation": "Precision to which the value of the quantity is expressed, in terms of number of decimal places. The value 0 implies an integral quantity.\nThe value -1 implies no limit, i.e. any number of decimal places.",
                    "type": "Integer"
                },
                "units": {
                    "name": "units",
                    "documentation": "Quantity units, expressed as a code or syntax string from either UCUM (the default) or the units system specified in `_units_system_`, when set.\n\nIn either case, the value is the code or syntax - normally formed of standard ASCII - which is in principal not the same as the display string, although in simple cases such as 'm' (for meters) it will be.\n\nIf the `_units_display_name_` field is set, this may be used for display. If not, the implementations must effect the resolution of the `_units_` value to a display form locally, e.g. by lookup of reference tables, request to a terminology service etc.\n\nExample values from UCUM: \"kg\/m^2\", \u201cmm[Hg]\", \"ms-1\", \"km\/h\".",
                    "is_mandatory": true,
                    "type": "String"
                },
                "normal_range": {
                    "_type": "P_BMM_GENERIC_PROPERTY",
                    "name": "normal_range",
                    "documentation": "Optional normal range. ",
                    "type_def": {
                        "root_type": "DV_INTERVAL",
                        "generic_parameters": [
                            "DV_QUANTITY"
                        ]
                    }
                },
                "other_reference_ranges": {
                    "_type": "P_BMM_CONTAINER_PROPERTY",
                    "name": "other_reference_ranges",
                    "documentation": "Optional tagged other reference ranges for this value in its particular measurement context.",
                    "type_def": {
                        "container_type": "List",
                        "type_def": {
                            "_type": "P_BMM_GENERIC_TYPE",
                            "root_type": "REFERENCE_RANGE",
                            "generic_parameters": [
                                "DV_QUANTITY"
                            ]
                        }
                    },
                    "cardinality": {
                        "lower": 0,
                        "upper_unbounded": true
                    }
                },
                "units_system": {
                    "name": "units_system",
                    "documentation": "Optional field used to specify a units system from which codes in `_units_` are defined. Value is a URI identifying a terminology containing units concepts from the  (https:\/\/www.hl7.org\/fhir\/terminologies-systems.html[HL7 FHIR terminologies list]).\n\nIf not set, the UCUM standard (case-sensitive codes) is assumed as the units system.",
                    "type": "String"
                },
                "units_display_name": {
                    "name": "units_display_name",
                    "documentation": "Optional field containing the displayable form of the `_units_` field, e.g. `'\u00b0C'`.\n\nIf not set, the application environment needs to determine the displayable form.\n\nNOTE: The display name may be language-dependent for various older and non-systematic units. For this reason, it is not recommended to add unit display names to archetypes, only to templates (for localisation purposes).",
                    "type": "String"
                }
            },
            "functions": {
                "add": {
                    "name": "add",
                    "documentation": "Sum of this `DV_QUANTITY` and `_other_`.",
                    "parameters": {
                        "other": {
                            "name": "other",
                            "type": "DV_QUANTITY"
                        }
                    },
                    "result": {
                        "type": "DV_QUANTITY"
                    }
                },
                "subtract": {
                    "name": "subtract",
                    "documentation": "Difference of this `DV_QUANTITY` and `_other_`.",
                    "parameters": {
                        "other": {
                            "name": "other",
                            "type": "DV_QUANTITY"
                        }
                    },
                    "result": {
                        "type": "DV_QUANTITY"
                    }
                },
                "multiply": {
                    "name": "multiply",
                    "documentation": "Product of this `DV_QUANTITY` and `_factor_`.",
                    "parameters": {
                        "factor": {
                            "name": "factor",
                            "type": "Real"
                        }
                    },
                    "result": {
                        "type": "DV_QUANTITY"
                    }
                },
                "less_than": {
                    "name": "less_than",
                    "documentation": "True if this Quantity object is less than `_other_`, based on comparison of `_magnitude_`. Only valid if `_is_strictly_comparable_to()_` is True.",
                    "parameters": {
                        "other": {
                            "name": "other",
                            "type": "DV_QUANTITY"
                        }
                    },
                    "pre_conditions": {
                        "Pre_comparable": "is_strictly_comparable()"
                    },
                    "post_conditions": {
                        "Post_result": "Result = magnitude < other.magnitude"
                    },
                    "result": {
                        "type": "Boolean"
                    }
                },
                "is_integral": {
                    "name": "is_integral",
                    "documentation": "True if `_precision_` = 0, meaning that the `_magnitude_` is a whole number.",
                    "result": {
                        "type": "Boolean"
                    }
                },
                "is_strictly_comparable_to": {
                    "name": "is_strictly_comparable_to",
                    "documentation": "True if this quantity and `_other_` have the same `_units_` and also `_units_system_` if it exists.",
                    "parameters": {
                        "other": {
                            "name": "other",
                            "type": "DV_ORDERED"
                        }
                    },
                    "result": {
                        "type": "Boolean"
                    }
                }
            }
        },
        "DV_COUNT": {
            "name": "DV_COUNT",
            "documentation": "Countable quantities. Used for countable types such as pregnancies and steps (taken by a physiotherapy patient), number of cigarettes smoked in a day. \n\nMisuse: Not to be used for amounts of physical entities (which all have units).",
            "ancestors": [
                "DV_AMOUNT"
            ],
            "properties": {
                "magnitude": {
                    "name": "magnitude",
                    "is_mandatory": true,
                    "type": "Integer64"
                },
                "normal_range": {
                    "_type": "P_BMM_GENERIC_PROPERTY",
                    "name": "normal_range",
                    "documentation": "Optional normal range. ",
                    "type_def": {
                        "root_type": "DV_INTERVAL",
                        "generic_parameters": [
                            "DV_COUNT"
                        ]
                    }
                },
                "other_reference_ranges": {
                    "_type": "P_BMM_CONTAINER_PROPERTY",
                    "name": "other_reference_ranges",
                    "documentation": "Optional tagged other reference ranges for this value in its particular measurement context.",
                    "type_def": {
                        "container_type": "List",
                        "type_def": {
                            "_type": "P_BMM_GENERIC_TYPE",
                            "root_type": "REFERENCE_RANGE",
                            "generic_parameters": [
                                "DV_COUNT"
                            ]
                        }
                    },
                    "cardinality": {
                        "lower": 0,
                        "upper_unbounded": true
                    }
                }
            },
            "functions": {
                "add": {
                    "name": "add",
                    "documentation": "Sum of this `DV_COUNT` and `_other_`.",
                    "parameters": {
                        "other": {
                            "name": "other",
                            "type": "DV_COUNT"
                        }
                    },
                    "result": {
                        "type": "DV_COUNT"
                    }
                },
                "subtract": {
                    "name": "subtract",
                    "documentation": "Difference of this `DV_COUNT` and `_other_`.",
                    "parameters": {
                        "other": {
                            "name": "other",
                            "type": "DV_COUNT"
                        }
                    },
                    "result": {
                        "type": "DV_COUNT"
                    }
                },
                "multiply": {
                    "name": "multiply",
                    "documentation": "Product of this `DV_COUNT` and `_factor_`.",
                    "parameters": {
                        "factor": {
                            "name": "factor",
                            "type": "Real"
                        }
                    },
                    "result": {
                        "type": "DV_COUNT"
                    }
                },
                "less_than": {
                    "name": "less_than",
                    "documentation": "True if this Quantified object is less than `_other_`, based on comparison of `_magnitude_`.",
                    "parameters": {
                        "other": {
                            "name": "other",
                            "type": "DV_COUNT"
                        }
                    },
                    "pre_conditions": {
                        "Pre_comparable": "is_strictly_comparable()"
                    },
                    "post_conditions": {
                        "Post_result": "Result = magnitude < other.magnitude"
                    },
                    "result": {
                        "type": "Boolean"
                    }
                },
                "is_strictly_comparable_to": {
                    "name": "is_strictly_comparable_to",
                    "documentation": "Return True.",
                    "parameters": {
                        "other": {
                            "name": "other",
                            "type": "DV_ORDERED"
                        }
                    },
                    "result": {
                        "type": "Boolean"
                    }
                }
            }
        },
        "DV_ABSOLUTE_QUANTITY": {
            "name": "DV_ABSOLUTE_QUANTITY",
            "documentation": "Abstract class defining the concept of quantified entities whose values are absolute with respect to an origin. Dates and Times are the main example.",
            "is_abstract": true,
            "ancestors": [
                "DV_QUANTIFIED"
            ],
            "properties": {
                "accuracy": {
                    "name": "accuracy",
                    "type": "DV_AMOUNT"
                }
            },
            "functions": {
                "add": {
                    "name": "add",
                    "documentation": "Addition of a differential amount to this quantity. \n\nThe value of accuracy in the result is either:\n\n* the sum of the accuracies of the operands, if both present, or;\n* unknown, if either or both operand accuracies are unknown.",
                    "is_abstract": true,
                    "parameters": {
                        "a_diff": {
                            "name": "a_diff",
                            "type": "DV_AMOUNT"
                        }
                    },
                    "result": {
                        "type": "DV_ABSOLUTE_QUANTITY"
                    }
                },
                "subtract": {
                    "name": "subtract",
                    "documentation": "Result of subtracting a differential amount from this quantity.\n\nThe value of `_accuracy_` in the result is either:\n\n* the sum of the accuracies of the operands, if both present, or;\n* unknown, if either or both operand accuracies are unknown.",
                    "is_abstract": true,
                    "parameters": {
                        "a_diff": {
                            "name": "a_diff",
                            "type": "DV_AMOUNT"
                        }
                    },
                    "result": {
                        "type": "DV_ABSOLUTE_QUANTITY"
                    }
                },
                "diff": {
                    "name": "diff",
                    "documentation": "Difference of two quantities.\n\nThe value of accuracy in the result is either:\n\n* the sum of the accuracies of the operands, if both present, or;\n* unknown, if either or both operand accuracies are unknown.",
                    "is_abstract": true,
                    "parameters": {
                        "other": {
                            "name": "other",
                            "type": "DV_ABSOLUTE_QUANTITY"
                        }
                    },
                    "result": {
                        "type": "DV_AMOUNT"
                    }
                }
            }
        },
        "DV_ORDINAL": {
            "name": "DV_ORDINAL",
            "documentation": "A data type that represents integral score values, e.g. pain, Apgar values, etc, where there is:\n\na) implied ordering, \nb) no implication that the distance between each value is constant, and \nc) the total number of values is finite;\nd) integer values only.\n\nNote that although the term 'ordinal' in mathematics means natural numbers only, here any integer is allowed, since negative and zero values are often used by medical professionals for values around a neutral point. Examples of sets of ordinal values: \n\n*   -3, -2, -1, 0, 1, 2, 3  -- reflex response values \n*    0, 1, 2                  -- Apgar values \n\nThis class is used for recording any clinical datum which is customarily recorded using symbolic values. Example: the results on a urinalysis strip, e.g. `{neg, trace, +, ++, +++}` are used for leucocytes, protein, nitrites etc; for non-haemolysed blood `{neg, trace, moderate}`; for haemolysed blood `{small, moderate, large}`.\n\nFor scores or scales that include Real numbers (or might in the future, i.e. not fixed for all time, such as Apgar), use `DV_SCALE`. `DV_SCALE` may also be used in future for representing purely Integer-based scales, however, the `DV_ORDINAL` type should continue to be supported in software implementations in order to accommodate existing data that are instances of this type.",
            "ancestors": [
                "DV_ORDERED"
            ],
            "properties": {
                "symbol": {
                    "name": "symbol",
                    "documentation": "Coded textual representation of this value in the enumeration, which may be strings made from  +  symbols, or other enumerations of terms such as  `mild`, `moderate`, `severe`, or even the same number series as the values, e.g. 1, 2, 3.",
                    "is_mandatory": true,
                    "type": "DV_CODED_TEXT"
                },
                "value": {
                    "name": "value",
                    "documentation": "Value in ordered enumeration of values. Any integer value can be used. \n",
                    "is_mandatory": true,
                    "type": "Integer"
                }
            },
            "functions": {
                "less_than": {
                    "name": "less_than",
                    "documentation": "True if this Ordinal value is less than `_other_`.",
                    "parameters": {
                        "other": {
                            "name": "other",
                            "type": "DV_ORDINAL"
                        }
                    },
                    "result": {
                        "type": "Boolean"
                    }
                },
                "is_strictly_comparable_to": {
                    "name": "is_strictly_comparable_to",
                    "documentation": "Test if this Ordinal is strictly comparable to `_other_`.",
                    "parameters": {
                        "other": {
                            "name": "other",
                            "type": "DV_ORDINAL"
                        }
                    },
                    "result": {
                        "type": "Boolean"
                    }
                }
            },
            "invariants": {
                "Limits_valid": "limits.meaning.is_equal (\u201climits\u201d)",
                "Reference_range_valid": "other_reference_ranges.has (limits)"
            }
        },
        "DV_SCALE": {
            "name": "DV_SCALE",
            "documentation": "A data type that represents scale values, where there is:\n\na) implied ordering, \nb) no implication that the distance between each value is constant, and \nc) the total number of values is finite;\nd) non-integer values are allowed.\n\nExample:\n\n----\nBorg CR 10 Scale\n\n0    No Breathlessness at all\n0.5  Very Very Slight (Just Noticeable)\n1    Very Slight\n2    Slight Breathlessness\n3    Moderate\n... etc\n----\n\nFor scores that include only Integers, `DV_SCALE` may also be used, but `DV_ORDINAL` should be supported to accommodate existing data instances of that type.",
            "ancestors": [
                "DV_ORDERED"
            ],
            "properties": {
                "symbol": {
                    "name": "symbol",
                    "documentation": "Coded textual representation of this value in the scale range, which may be strings made from symbols or other enumerations of terms such as  `no breathlessness`, `very very slight`, `slight breathlessness`. Codes come from archetypes.\n\nIn some cases, a scale may include values that have no code\/symbol. In this case, the symbol will be a `DV-CODED_TEXT` including the `_terminology_id_` and a blank String value for `_code_string_`.",
                    "is_mandatory": true,
                    "type": "DV_CODED_TEXT"
                },
                "value": {
                    "name": "value",
                    "documentation": "Real number value of Scale item.\n",
                    "is_mandatory": true,
                    "type": "Real"
                }
            },
            "functions": {
                "is_strictly_comparable_to": {
                    "name": "is_strictly_comparable_to",
                    "documentation": "Test if this Scale value is strictly comparable to `_other_`.",
                    "parameters": {
                        "other": {
                            "name": "other",
                            "type": "DV_SCALE"
                        }
                    },
                    "result": {
                        "type": "Boolean"
                    }
                },
                "less_than": {
                    "name": "less_than",
                    "documentation": "True if this Scale value is less than `_other_`.",
                    "parameters": {
                        "other": {
                            "name": "other",
                            "type": "DV_SCALE"
                        }
                    },
                    "result": {
                        "type": "Boolean"
                    }
                }
            }
        },
        "DV_DURATION": {
            "name": "DV_DURATION",
            "documentation": "Represents a period of time with respect to a notional point in time, which is not specified. A sign may be used to indicate the duration is  backwards  in time rather than forwards. \n\nNOTE: two deviations from ISO 8601 are supported, the first, to allow a negative sign, and the second allowing the 'W' designator to be mixed with other designators. See time types section in the Foundation Types model. \n\nUsed for recording the duration of something in the real world, particularly when there is a need a) to represent the duration in customary format, i.e. days, hours, minutes etc, and b) if it will be used in computational operations with date\/time quantities, i.e. additions, subtractions etc. \n\nMisuse: Durations cannot be used to represent points in time, or intervals of time. ",
            "ancestors": [
                "DV_AMOUNT",
                "Iso8601_duration"
            ],
            "properties": {
                "value": {
                    "name": "value",
                    "documentation": "ISO8601 duration string, including described deviations to support negative values and weeks.",
                    "is_mandatory": true,
                    "type": "String"
                }
            },
            "functions": {
                "add": {
                    "name": "add",
                    "documentation": "Sum of this Duration and `_other_`.",
                    "parameters": {
                        "other": {
                            "name": "other",
                            "type": "DV_DURATION"
                        }
                    },
                    "result": {
                        "type": "DV_DURATION"
                    }
                },
                "subtract": {
                    "name": "subtract",
                    "documentation": "Difference of this Duration and `_other_`.",
                    "parameters": {
                        "other": {
                            "name": "other",
                            "type": "DV_DURATION"
                        }
                    },
                    "result": {
                        "type": "DV_DURATION"
                    }
                },
                "multiply": {
                    "name": "multiply",
                    "documentation": "Product of this Duration and `_factor_`.",
                    "parameters": {
                        "factor": {
                            "name": "factor",
                            "type": "Real"
                        }
                    },
                    "result": {
                        "type": "DV_DURATION"
                    }
                },
                "less_than": {
                    "name": "less_than",
                    "documentation": "True if this duration object is less than `_other_`, based on comparison of `_magnitude()_`. ",
                    "parameters": {
                        "other": {
                            "name": "other",
                            "type": "DV_DURATION"
                        }
                    },
                    "pre_conditions": {
                        "Pre_comparable": "is_strictly_comparable()"
                    },
                    "post_conditions": {
                        "Post_result": "Result = magnitude < other.magnitude"
                    },
                    "result": {
                        "type": "Boolean"
                    }
                },
                "is_strictly_comparable_to": {
                    "name": "is_strictly_comparable_to",
                    "documentation": "True, for any two Durations.",
                    "parameters": {
                        "other": {
                            "name": "other",
                            "type": "DV_DURATION"
                        }
                    },
                    "result": {
                        "type": "Boolean"
                    }
                },
                "negative": {
                    "name": "negative",
                    "documentation": "Negated version of current duration.\n\nAssuming the current duration is positive, the negated version represents a time prior to some origin point, or a negative age (e.g. so-called 'adjusted age' of premature infant).",
                    "result": {
                        "type": "DV_DURATION"
                    }
                },
                "magnitude": {
                    "name": "magnitude",
                    "documentation": "Numeric value of the duration as a number of seconds. Computed using the method `_to_seconds()_` inherited from `Iso8601_duration`.",
                    "result": {
                        "type": "Double"
                    }
                }
            },
            "invariants": {
                "Value_valid": "valid_iso8601_duration (value)"
            }
        },
        "DV_TEMPORAL": {
            "name": "DV_TEMPORAL",
            "documentation": "Specialised temporal variant of `DV_ABSOLUTE_QUANTITY` whose diff type is `DV_DURATION`. ",
            "is_abstract": true,
            "ancestors": [
                "DV_ABSOLUTE_QUANTITY"
            ],
            "properties": {
                "accuracy": {
                    "name": "accuracy",
                    "documentation": "Time accuracy, expressed as a duration.",
                    "type": "DV_DURATION"
                }
            },
            "functions": {
                "add": {
                    "name": "add",
                    "documentation": "Addition of a Duration to this temporal entity.",
                    "is_abstract": true,
                    "parameters": {
                        "a_diff": {
                            "name": "a_diff",
                            "type": "DV_DURATION"
                        }
                    },
                    "result": {
                        "type": "DV_TEMPORAL"
                    }
                },
                "subtract": {
                    "name": "subtract",
                    "documentation": "Subtract a Duration from this temporal entity.",
                    "is_abstract": true,
                    "parameters": {
                        "a_diff": {
                            "name": "a_diff",
                            "type": "DV_DURATION"
                        }
                    },
                    "result": {
                        "type": "DV_TEMPORAL"
                    }
                },
                "diff": {
                    "name": "diff",
                    "documentation": "Difference between this temporal entity and `_other_`.",
                    "is_abstract": true,
                    "parameters": {
                        "other": {
                            "name": "other",
                            "type": "DV_TEMPORAL"
                        }
                    },
                    "result": {
                        "type": "DV_DURATION"
                    }
                }
            }
        },
        "DV_DATE": {
            "name": "DV_DATE",
            "documentation": "Represents an absolute point in time, as measured on the Gregorian calendar, and specified only to the day. Semantics defined by ISO 8601. Used for recording dates in real world time. The partial form is used for approximate birth dates, dates of death, etc.\n",
            "ancestors": [
                "DV_TEMPORAL",
                "Iso8601_date"
            ],
            "properties": {
                "value": {
                    "name": "value",
                    "documentation": "ISO8601 date string.",
                    "is_mandatory": true,
                    "type": "String"
                }
            },
            "functions": {
                "magnitude": {
                    "name": "magnitude",
                    "documentation": "Numeric value of the date as days since the calendar origin date `0001-01-01`.",
                    "result": {
                        "type": "Integer"
                    }
                },
                "is_equal": {
                    "name": "is_equal",
                    "documentation": "Return True if this `DV_QUANTIFIED` is considered equal to `_other_`.",
                    "parameters": {
                        "other": {
                            "name": "other",
                            "type": "DV_QUANTIFIED"
                        }
                    },
                    "result": {
                        "type": "Boolean"
                    }
                },
                "add": {
                    "name": "add",
                    "documentation": "Addition of a Duration to this Date.",
                    "parameters": {
                        "a_diff": {
                            "name": "a_diff",
                            "type": "DV_DURATION"
                        }
                    },
                    "result": {
                        "type": "DV_DATE"
                    }
                },
                "subtract": {
                    "name": "subtract",
                    "documentation": "Subtract a Duration from this Date.",
                    "parameters": {
                        "a_diff": {
                            "name": "a_diff",
                            "type": "DV_DURATION"
                        }
                    },
                    "result": {
                        "type": "DV_DATE"
                    }
                },
                "diff": {
                    "name": "diff",
                    "documentation": "Difference between this Date and `_other_`.",
                    "parameters": {
                        "other": {
                            "name": "other",
                            "type": "DV_DATE"
                        }
                    },
                    "result": {
                        "type": "DV_DURATION"
                    }
                },
                "less_than": {
                    "name": "less_than",
                    "documentation": "True if this date object is less than `_other_`, based on comparison of `_magnitude()_`. ",
                    "parameters": {
                        "other": {
                            "name": "other",
                            "type": "DV_DATE"
                        }
                    },
                    "pre_conditions": {
                        "Pre_comparable": "is_strictly_comparable()"
                    },
                    "post_conditions": {
                        "Post_result": "Result = magnitude < other.magnitude"
                    },
                    "result": {
                        "type": "Boolean"
                    }
                },
                "is_strictly_comparable_to": {
                    "name": "is_strictly_comparable_to",
                    "documentation": "True, for any two Dates.",
                    "parameters": {
                        "other": {
                            "name": "other",
                            "type": "DV_DATE"
                        }
                    },
                    "result": {
                        "type": "Boolean"
                    }
                }
            },
            "invariants": {
                "Value_valid": "valid_iso8601_date(value)"
            }
        },
        "DV_TIME": {
            "name": "DV_TIME",
            "documentation": "Represents an absolute point in time from an origin usually interpreted as meaning the start of the current day, specified to a fraction of a second. Semantics defined by ISO 8601. \n\nUsed for recording real world times, rather than scientifically measured fine amounts of time. The partial form is used for approximate times of events and substance administrations. ",
            "ancestors": [
                "DV_TEMPORAL",
                "Iso8601_time"
            ],
            "properties": {
                "value": {
                    "name": "value",
                    "documentation": "ISO8601 time string",
                    "is_mandatory": true,
                    "type": "String"
                }
            },
            "functions": {
                "magnitude": {
                    "name": "magnitude",
                    "documentation": "Numeric value of the time as seconds since the start of day, i.e. `00:00:00`. ",
                    "result": {
                        "type": "Real"
                    }
                },
                "add": {
                    "name": "add",
                    "documentation": "Addition of a Duration to this Time.",
                    "parameters": {
                        "a_diff": {
                            "name": "a_diff",
                            "type": "DV_DURATION"
                        }
                    },
                    "result": {
                        "type": "DV_TIME"
                    }
                },
                "subtract": {
                    "name": "subtract",
                    "documentation": "Subtract a Duration from this Time.",
                    "parameters": {
                        "a_diff": {
                            "name": "a_diff",
                            "type": "DV_DURATION"
                        }
                    },
                    "result": {
                        "type": "DV_TIME"
                    }
                },
                "diff": {
                    "name": "diff",
                    "documentation": "Difference between this Time and `_other_`.",
                    "parameters": {
                        "other": {
                            "name": "other",
                            "type": "DV_TIME"
                        }
                    },
                    "result": {
                        "type": "DV_DURATION"
                    }
                },
                "less_than": {
                    "name": "less_than",
                    "documentation": "True if this time object is less than `_other_`, based on comparison of `_magnitude()_`. ",
                    "parameters": {
                        "other": {
                            "name": "other",
                            "type": "DV_TIME"
                        }
                    },
                    "pre_conditions": {
                        "Pre_comparable": "is_strictly_comparable()"
                    },
                    "post_conditions": {
                        "Post_result": "Result = magnitude < other.magnitude"
                    },
                    "result": {
                        "type": "Boolean"
                    }
                },
                "is_strictly_comparable_to": {
                    "name": "is_strictly_comparable_to",
                    "documentation": "True, for any two Times.",
                    "parameters": {
                        "other": {
                            "name": "other",
                            "type": "DV_TIME"
                        }
                    },
                    "result": {
                        "type": "Boolean"
                    }
                }
            },
            "invariants": {
                "Value_valid": "valid_iso8601_time (value)"
            }
        },
        "DV_DATE_TIME": {
            "name": "DV_DATE_TIME",
            "documentation": "Represents an absolute point in time, specified to the second. Semantics defined by ISO 8601. \n\nUsed for recording a precise point in real world time, and for approximate time stamps, e.g. the origin of a `HISTORY` in an `OBSERVATION` which is only partially known. \n",
            "ancestors": [
                "DV_TEMPORAL",
                "Iso8601_date_time"
            ],
            "properties": {
                "value": {
                    "name": "value",
                    "documentation": "ISO8601 date\/time string.",
                    "is_mandatory": true,
                    "type": "String"
                }
            },
            "functions": {
                "magnitude": {
                    "name": "magnitude",
                    "documentation": "Numeric value of the date\/time as seconds since the calendar origin date\/time `0001-01-01T00:00:00Z`. \n",
                    "result": {
                        "type": "Double"
                    }
                },
                "add": {
                    "name": "add",
                    "documentation": "Addition of a Duration to this Date\/time.",
                    "parameters": {
                        "a_diff": {
                            "name": "a_diff",
                            "type": "DV_DURATION"
                        }
                    },
                    "result": {
                        "type": "DV_DATE_TIME"
                    }
                },
                "subtract": {
                    "name": "subtract",
                    "documentation": "Subtract a Duration from this Date\/time.",
                    "parameters": {
                        "a_diff": {
                            "name": "a_diff",
                            "type": "DV_DURATION"
                        }
                    },
                    "result": {
                        "type": "DV_DATE_TIME"
                    }
                },
                "diff": {
                    "name": "diff",
                    "documentation": "Difference between this Date\/time and `_other_`.",
                    "parameters": {
                        "other": {
                            "name": "other",
                            "type": "DV_DATE_TIME"
                        }
                    },
                    "result": {
                        "type": "DV_DURATION"
                    }
                },
                "less_than": {
                    "name": "less_than",
                    "documentation": "True if this date-time object is less than `_other_`, based on comparison of `_magnitude()_`. ",
                    "parameters": {
                        "other": {
                            "name": "other",
                            "type": "DV_DATE_TIME"
                        }
                    },
                    "pre_conditions": {
                        "Pre_comparable": "is_strictly_comparable()"
                    },
                    "post_conditions": {
                        "Post_result": "Result = magnitude < other.magnitude"
                    },
                    "result": {
                        "type": "Boolean"
                    }
                },
                "is_strictly_comparable_to": {
                    "name": "is_strictly_comparable_to",
                    "documentation": "True, for any two Date\/times.",
                    "parameters": {
                        "other": {
                            "name": "other",
                            "type": "DV_DATE_TIME"
                        }
                    },
                    "result": {
                        "type": "Boolean"
                    }
                }
            },
            "invariants": {
                "Value_valid": "valid_iso8601_date_time (value)"
            }
        },
        "DV_TIME_SPECIFICATION": {
            "name": "DV_TIME_SPECIFICATION",
            "documentation": "This is an abstract class of which all timing specifications are specialisations. Specifies points in time, possibly linked to the calendar, or a real world repeating event, such as  breakfast. ",
            "is_abstract": true,
            "ancestors": [
                "DATA_VALUE"
            ],
            "properties": {
                "value": {
                    "name": "value",
                    "documentation": "The specification, in the HL7v3 syntax for `PIVL` or `EIVL` types.",
                    "is_mandatory": true,
                    "type": "DV_PARSABLE"
                }
            },
            "functions": {
                "calendar_alignment": {
                    "name": "calendar_alignment",
                    "documentation": "Indicates what prototypical point in the calendar the specification is aligned to, e.g.  5th of the month . Empty if not aligned. Extracted from the  value' attribute.",
                    "is_abstract": true,
                    "result": {
                        "type": "String"
                    }
                },
                "event_alignment": {
                    "name": "event_alignment",
                    "documentation": "Indicates what real-world event the specification is aligned to if any. Extracted from the  value' attribute. ",
                    "is_abstract": true,
                    "result": {
                        "type": "String"
                    }
                },
                "institution_specified": {
                    "name": "institution_specified",
                    "documentation": "Indicates if the specification is aligned with institution schedules, e.g. a hospital nursing changeover or meal serving times. Extracted from the  value' attribute.",
                    "is_abstract": true,
                    "result": {
                        "type": "Boolean"
                    }
                }
            }
        },
        "DV_PERIODIC_TIME_SPECIFICATION": {
            "name": "DV_PERIODIC_TIME_SPECIFICATION",
            "documentation": "Specifies periodic points in time, linked to the calendar (phase-linked), or a real world repeating event, such as  breakfast  (event-linked). Based on the HL7v3 data types `PIVL<T>` and `EIVL<T>`. \n\nUsed in therapeutic prescriptions, expressed as `INSTRUCTIONs` in the openEHR model. ",
            "ancestors": [
                "DV_TIME_SPECIFICATION"
            ],
            "functions": {
                "period": {
                    "name": "period",
                    "documentation": "The period of the repetition, computationally derived from the syntax representation. Extracted from the  value' attribute.",
                    "result": {
                        "type": "DV_DURATION"
                    }
                },
                "calendar_alignment": {
                    "name": "calendar_alignment",
                    "documentation": "Calendar alignment extracted from value. ",
                    "result": {
                        "type": "String"
                    }
                },
                "event_alignment": {
                    "name": "event_alignment",
                    "documentation": "Event alignment extracted from value. ",
                    "result": {
                        "type": "String"
                    }
                },
                "institution_specified": {
                    "name": "institution_specified",
                    "documentation": "Extracted from value.",
                    "result": {
                        "type": "Boolean"
                    }
                }
            },
            "invariants": {
                "Value_valid": "value.formalism.is_equal (\u201cHL7:PIVL\u201d) or value.formalism. is_equal (\u201cHL7:EIVL\u201d)"
            }
        },
        "DV_GENERAL_TIME_SPECIFICATION": {
            "name": "DV_GENERAL_TIME_SPECIFICATION",
            "documentation": "Specifies points in time in a general syntax. Based on the HL7v3 GTS data type.",
            "ancestors": [
                "DV_TIME_SPECIFICATION"
            ],
            "functions": {
                "calendar_alignment": {
                    "name": "calendar_alignment",
                    "documentation": "Calendar alignment extracted from value.",
                    "result": {
                        "type": "String"
                    }
                },
                "event_alignment": {
                    "name": "event_alignment",
                    "documentation": "Event alignment extracted from value. ",
                    "result": {
                        "type": "String"
                    }
                },
                "institution_specified": {
                    "name": "institution_specified",
                    "documentation": "Extracted from value.",
                    "result": {
                        "type": "Boolean"
                    }
                }
            }
        },
        "DV_URI": {
            "name": "DV_URI",
            "documentation": "A reference to an object which structurally conforms to the Universal Resource Identifier (URI) RFC-3986 standard. The reference is contained in the `_value_` attribute, which is a `String`. So-called 'plain-text URIs' that contain RFC-3986 forbidden characters such as spaces etc, are allowed on the basis that they need to be RFC-3986 encoded prior to use in e.g. REST APIs or other contexts relying on machine-level conformance.",
            "ancestors": [
                "DATA_VALUE"
            ],
            "properties": {
                "value": {
                    "name": "value",
                    "documentation": "Value of URI as a String. 'Plain-text' URIs are allowed, enabling better readability, but must be RFC-3986 encoded in use.",
                    "is_mandatory": true,
                    "type": "String"
                }
            },
            "functions": {
                "scheme": {
                    "name": "scheme",
                    "documentation": "A distributed information 'space' in which  information objects  exist. The scheme simultaneously specifies an information space and a mechanism for accessing objects in  that  space.  For  example  if  scheme  = \"ftp\", it identifies the information space in which  all  ftp-able objects  exist,  and also the application - ftp - which can be used to access them. Values may include: \"ftp\", \"telnet\", \"mailto\", etc. Refer to RFC-3986 for a full list. \n",
                    "result": {
                        "type": "String"
                    }
                },
                "path": {
                    "name": "path",
                    "documentation": "A string whose format is  a  function  of  the  scheme. Identifies   the   location  in  <scheme>-space  of  an information entity. Typical values include hierarchical directory  paths  for  any  machine.  For example, with scheme = \"ftp\", path might be `\"\/pub\/images\/image_01\"`. The strings \".\" and \"..\" are reserved for use in the path. Paths may include internet\/intranet location identifiers of the form: `sub_domain...domain`, e.g. `\"info.cern.ch\"`. ",
                    "result": {
                        "type": "String"
                    }
                },
                "fragment_id": {
                    "name": "fragment_id",
                    "documentation": "A part of, a  fragment  or  a  sub-function  within  an object. Allows references to sub-parts of objects, such as a certain line and character  position  in  a  text object. The  syntax  and semantics are defined by the application responsible for the object. \n",
                    "result": {
                        "type": "String"
                    }
                },
                "query": {
                    "name": "query",
                    "documentation": "Query string to send to application implied  by  scheme and  path.  Enables  queries  to applications, including databases  to  be  included in  the  URI. Supports any query meaningful to the server, including SQL. \n",
                    "result": {
                        "type": "String"
                    }
                }
            },
            "invariants": {
                "Value_valid": "not value.is_empty"
            }
        },
        "DV_EHR_URI": {
            "name": "DV_EHR_URI",
            "documentation": "A `DV_EHR_URI` is a `DV_URI` which has the scheme name 'ehr', and which can only reference items in EHRs. \n\nUsed to reference items in an EHR, which may be the same as the current EHR (containing this link), or another.",
            "ancestors": [
                "DV_URI"
            ],
            "invariants": {
                "Scheme_valid": "scheme.is_equal (Ehr_scheme)"
            }
        },
        "EXTERNAL_ENVIRONMENT_ACCESS": {
            "name": "EXTERNAL_ENVIRONMENT_ACCESS",
            "documentation": "A mixin class providing access to services in the external environment.",
            "is_abstract": true,
            "ancestors": [
                "TERMINOLOGY_SERVICE",
                "MEASUREMENT_SERVICE"
            ]
        },
        "MEASUREMENT_SERVICE": {
            "name": "MEASUREMENT_SERVICE",
            "documentation": "Defines an object providing proxy access to a measurement information service.",
            "functions": {
                "is_valid_units_string": {
                    "name": "is_valid_units_string",
                    "documentation": "True if the units string  units' is a valid string according to the HL7 UCUM specification.",
                    "parameters": {
                        "units": {
                            "name": "units",
                            "type": "String"
                        }
                    },
                    "result": {
                        "type": "Boolean"
                    }
                },
                "units_equivalent": {
                    "name": "units_equivalent",
                    "documentation": "True if two units strings correspond to the same measured property.",
                    "parameters": {
                        "units1": {
                            "name": "units1",
                            "type": "String"
                        },
                        "units2": {
                            "name": "units2",
                            "type": "String"
                        }
                    },
                    "result": {
                        "type": "Boolean"
                    }
                }
            }
        },
        "OPENEHR_TERMINOLOGY_GROUP_IDENTIFIERS": {
            "name": "OPENEHR_TERMINOLOGY_GROUP_IDENTIFIERS",
            "documentation": "List of identifiers for groups in the openEHR terminology. ",
            "constants": {
                "Terminology_id_openehr": {
                    "name": "Terminology_id_openehr",
                    "documentation": "Name of openEHR's own terminology.",
                    "type": "String",
                    "value": "\"openehr\""
                },
                "Group_id_audit_change_type": {
                    "name": "Group_id_audit_change_type",
                    "type": "String",
                    "value": "\"audit change type\""
                },
                "Group_id_attestation_reason": {
                    "name": "Group_id_attestation_reason",
                    "type": "String",
                    "value": "\"attestation reason\""
                },
                "Group_id_composition_category": {
                    "name": "Group_id_composition_category",
                    "type": "String",
                    "value": "\"composition category\""
                },
                "Group_id_event_math_function": {
                    "name": "Group_id_event_math_function",
                    "type": "String",
                    "value": "\"event math function\""
                },
                "Group_id_instruction_states": {
                    "name": "Group_id_instruction_states",
                    "type": "String",
                    "value": "\"instruction states\""
                },
                "Group_id_instruction_transitions": {
                    "name": "Group_id_instruction_transitions",
                    "type": "String",
                    "value": "\"instruction transitions\""
                },
                "Group_id_null_flavours": {
                    "name": "Group_id_null_flavours",
                    "type": "String",
                    "value": "\"null flavours\""
                },
                "Group_id_property": {
                    "name": "Group_id_property",
                    "type": "String",
                    "value": "\"property\""
                },
                "Group_id_participation_function": {
                    "name": "Group_id_participation_function",
                    "type": "String",
                    "value": "\"participation function\""
                },
                "Group_id_participation_mode": {
                    "name": "Group_id_participation_mode",
                    "type": "String",
                    "value": "\"participation mode\""
                },
                "Group_id_setting": {
                    "name": "Group_id_setting",
                    "type": "String",
                    "value": "\"setting\""
                },
                "Group_id_term_mapping_purpose": {
                    "name": "Group_id_term_mapping_purpose",
                    "type": "String",
                    "value": "\"term mapping purpose\""
                },
                "Group_id_subject_relationship": {
                    "name": "Group_id_subject_relationship",
                    "type": "String",
                    "value": "\"subject relationship\""
                },
                "Group_id_version_life_cycle_state": {
                    "name": "Group_id_version_life_cycle_state",
                    "type": "String",
                    "value": "\"version lifecycle state\""
                }
            },
            "functions": {
                "valid_terminology_group_id": {
                    "name": "valid_terminology_group_id",
                    "documentation": "Validity function to test if an identifier is in the set defined by this class. ",
                    "parameters": {
                        "an_id": {
                            "name": "an_id",
                            "type": "Boolean"
                        }
                    },
                    "result": {
                        "type": "Boolean"
                    }
                }
            }
        },
        "OPENEHR_CODE_SET_IDENTIFIERS": {
            "name": "OPENEHR_CODE_SET_IDENTIFIERS",
            "documentation": "List of identifiers for code sets in the openEHR terminology. ",
            "constants": {
                "Code_set_id_character_sets": {
                    "name": "Code_set_id_character_sets",
                    "type": "String",
                    "value": "\"character sets\""
                },
                "Code_set_id_compression_algorithms": {
                    "name": "Code_set_id_compression_algorithms",
                    "type": "String",
                    "value": "\"compression algorithms\""
                },
                "Code_set_id_countries": {
                    "name": "Code_set_id_countries",
                    "type": "String",
                    "value": "\"countries\""
                },
                "Code_set_integrity_check_algorithms": {
                    "name": "Code_set_integrity_check_algorithms",
                    "type": "String",
                    "value": "\"integrity check algorithms\""
                },
                "Code_set_id_languages": {
                    "name": "Code_set_id_languages",
                    "type": "String",
                    "value": "\"languages\""
                },
                "Code_set_id_media_types": {
                    "name": "Code_set_id_media_types",
                    "type": "String",
                    "value": "\"media types\""
                },
                "Code_set_id_normal_statuses": {
                    "name": "Code_set_id_normal_statuses",
                    "type": "String",
                    "value": "\"normal statuses\""
                }
            },
            "functions": {
                "valid_code_set_id": {
                    "name": "valid_code_set_id",
                    "documentation": "Validity function to test if an identifier is in the set defined by this class.",
                    "parameters": {
                        "an_id": {
                            "name": "an_id",
                            "type": "String"
                        }
                    },
                    "result": {
                        "type": "Boolean"
                    }
                }
            }
        },
        "TERMINOLOGY_SERVICE": {
            "name": "TERMINOLOGY_SERVICE",
            "documentation": "Defines an object providing proxy access to a terminology service. ",
            "ancestors": [
                "OPENEHR_TERMINOLOGY_GROUP_IDENTIFIERS",
                "OPENEHR_CODE_SET_IDENTIFIERS"
            ],
            "functions": {
                "terminology": {
                    "name": "terminology",
                    "documentation": "Return an interface to the terminology named name. Allowable names include:-\n\n* openehr, \n* centc251,\n* any name from are taken from the US NLM UMLS meta-data list at http:\/\/www.nlm.nih.gov\/research\/umls\/metaa1.html ",
                    "parameters": {
                        "name": {
                            "name": "name",
                            "type": "String"
                        }
                    },
                    "result": {
                        "type": "TERMINOLOGY_ACCESS"
                    }
                },
                "code_set": {
                    "name": "code_set",
                    "documentation": "Return an interface to the code_set identified by the external identifier name (e.g.  ISO_639-1). ",
                    "parameters": {
                        "name": {
                            "name": "name",
                            "type": "String"
                        }
                    },
                    "pre_conditions": {
                        "Pre": "has_code_set (name)"
                    },
                    "result": {
                        "type": "CODE_SET_ACCESS"
                    }
                },
                "code_set_for_id": {
                    "name": "code_set_for_id",
                    "documentation": "Return an interface to the code_set identified internally in openEHR by id. \n",
                    "parameters": {
                        "id": {
                            "name": "id",
                            "type": "String"
                        }
                    },
                    "pre_conditions": {
                        "Pre": "valid_code_set_id (id)"
                    },
                    "result": {
                        "type": "CODE_SET_ACCESS"
                    }
                },
                "has_terminology": {
                    "name": "has_terminology",
                    "documentation": "True if terminology named name known by this service. Allowable names include:-\n\n*  openehr  \n* centc251  \n* any name from are taken from the US NLM UMLS meta-data list at       http:\/\/www.nlm.nih.gov\/research\/umls\/metaa1.html",
                    "parameters": {
                        "name": {
                            "name": "name",
                            "type": "String"
                        }
                    },
                    "result": {
                        "type": "Boolean"
                    }
                },
                "has_code_set": {
                    "name": "has_code_set",
                    "documentation": "True if code_set linked to internal name (e.g. languages ) is available. ",
                    "parameters": {
                        "name": {
                            "name": "name",
                            "type": "String"
                        }
                    },
                    "result": {
                        "type": "Boolean"
                    }
                },
                "terminology_identifiers": {
                    "name": "terminology_identifiers",
                    "documentation": "Set of all terminology identifiers known in the terminology service. Values from the US NLM UMLS meta-data list at:- http:\/\/www.nlm.nih.gov\/research\/umls\/metaa1.html ",
                    "result": {
                        "_type": "P_BMM_CONTAINER_TYPE",
                        "container_type": "List",
                        "type": "String"
                    },
                    "is_nullable": true
                },
                "openehr_code_sets": {
                    "name": "openehr_code_sets",
                    "documentation": "Set of all code set identifiers known in the terminology service. \n",
                    "result": {
                        "_type": "P_BMM_GENERIC_TYPE",
                        "root_type": "Hash",
                        "generic_parameters": [
                            "String",
                            "String"
                        ]
                    }
                },
                "code_set_identifiers": {
                    "name": "code_set_identifiers",
                    "documentation": "Set of all code sets identifiers for which there is an internal openEHR name; returned as a Map of ids keyed by internal name. ",
                    "result": {
                        "_type": "P_BMM_CONTAINER_TYPE",
                        "container_type": "List",
                        "type": "String"
                    },
                    "is_nullable": true
                }
            }
        },
        "CODE_SET_ACCESS": {
            "name": "CODE_SET_ACCESS",
            "documentation": "Defines an object providing proxy access to a code_set.",
            "functions": {
                "id": {
                    "name": "id",
                    "documentation": "External identifier of this code set.",
                    "result": {
                        "type": "String"
                    }
                },
                "all_codes": {
                    "name": "all_codes",
                    "documentation": "Return all codes known in this code set.",
                    "result": {
                        "_type": "P_BMM_CONTAINER_TYPE",
                        "container_type": "List",
                        "type": "CODE_PHRASE"
                    },
                    "is_nullable": true
                },
                "has_lang": {
                    "name": "has_lang",
                    "documentation": "True if code set knows about 'a_lang' .",
                    "parameters": {
                        "a_lang": {
                            "name": "a_lang",
                            "type": "String"
                        }
                    },
                    "result": {
                        "type": "Boolean"
                    }
                },
                "has_code": {
                    "name": "has_code",
                    "documentation": "True if code set knows about  'a_code'.",
                    "parameters": {
                        "a_code": {
                            "name": "a_code",
                            "type": "String"
                        }
                    },
                    "result": {
                        "type": "Boolean"
                    }
                }
            }
        },
        "TERMINOLOGY_ACCESS": {
            "name": "TERMINOLOGY_ACCESS",
            "documentation": "Defines an object providing proxy access to a terminology. ",
            "functions": {
                "id": {
                    "name": "id",
                    "documentation": "Identification of this Terminology.",
                    "result": {
                        "type": "String"
                    }
                },
                "all_codes": {
                    "name": "all_codes",
                    "documentation": "Return all codes known in this terminology.",
                    "result": {
                        "type": "CODE_PHRASE"
                    }
                },
                "codes_for_group_id": {
                    "name": "codes_for_group_id",
                    "documentation": "Return all codes under grouper 'a_group_id' from this terminology.",
                    "parameters": {
                        "a_group_id": {
                            "name": "a_group_id",
                            "type": "String"
                        }
                    },
                    "result": {
                        "_type": "P_BMM_CONTAINER_TYPE",
                        "container_type": "List",
                        "type": "CODE_PHRASE"
                    },
                    "is_nullable": true
                },
                "codes_for_group_name": {
                    "name": "codes_for_group_name",
                    "documentation": "Return all codes under grouper whose name in 'a_lang' is 'a_name' from this terminology.",
                    "parameters": {
                        "a_lang": {
                            "name": "a_lang",
                            "type": "String"
                        },
                        "a_name": {
                            "name": "a_name",
                            "type": "String"
                        }
                    },
                    "result": {
                        "_type": "P_BMM_CONTAINER_TYPE",
                        "container_type": "List",
                        "type": "CODE_PHRASE"
                    },
                    "is_nullable": true
                },
                "has_code_for_group_id": {
                    "name": "has_code_for_group_id",
                    "documentation": "True if  a_code' is known in group  group_id' in the openEHR terminology.",
                    "result": {
                        "type": "Boolean"
                    }
                },
                "rubric_for_code": {
                    "name": "rubric_for_code",
                    "documentation": "Return all rubric of code  code' in language  lang'.",
                    "parameters": {
                        "a_code": {
                            "name": "a_code",
                            "type": "String"
                        }
                    },
                    "result": {
                        "type": "String"
                    }
                }
            }
        },
        "EHR": {
            "name": "EHR",
            "documentation": "The EHR object is the root object and access point of an EHR for a subject of care. ",
            "properties": {
                "system_id": {
                    "name": "system_id",
                    "documentation": "The identifier of the logical EHR management system in which this EHR was created. \n",
                    "is_mandatory": true,
                    "type": "HIER_OBJECT_ID"
                },
                "ehr_id": {
                    "name": "ehr_id",
                    "documentation": "The unique identifier of this EHR.\n\nNOTE: is is strongly recommended that a UUID always be used for this field.",
                    "is_mandatory": true,
                    "type": "HIER_OBJECT_ID"
                },
                "contributions": {
                    "_type": "P_BMM_CONTAINER_PROPERTY",
                    "name": "contributions",
                    "documentation": "List of contributions causing changes to this EHR. Each contribution contains a list of versions, which may include references to any number of `VERSION` instances, i.e. items of type `VERSIONED_COMPOSITION` and `VERSIONED_FOLDER`. ",
                    "type_def": {
                        "container_type": "List",
                        "type": "OBJECT_REF"
                    },
                    "cardinality": {
                        "lower": 0,
                        "upper_unbounded": true
                    }
                },
                "ehr_status": {
                    "name": "ehr_status",
                    "documentation": "Reference to `EHR_STATUS` object for this EHR.",
                    "is_mandatory": true,
                    "type": "OBJECT_REF"
                },
                "ehr_access": {
                    "name": "ehr_access",
                    "documentation": "Reference to `EHR_ACCESS` object for this EHR.",
                    "is_mandatory": true,
                    "type": "OBJECT_REF"
                },
                "compositions": {
                    "_type": "P_BMM_CONTAINER_PROPERTY",
                    "name": "compositions",
                    "documentation": "Master list of all Versioned Composition references in this EHR.",
                    "type_def": {
                        "container_type": "List",
                        "type": "OBJECT_REF"
                    },
                    "cardinality": {
                        "lower": 0,
                        "upper_unbounded": true
                    }
                },
                "directory": {
                    "name": "directory",
                    "documentation": "Optional directory structure for this EHR. If present, this is a reference to the first member of `_folders_`.",
                    "type": "OBJECT_REF"
                },
                "time_created": {
                    "name": "time_created",
                    "documentation": "Time of creation of the EHR.",
                    "is_mandatory": true,
                    "type": "DV_DATE_TIME"
                },
                "folders": {
                    "_type": "P_BMM_CONTAINER_PROPERTY",
                    "name": "folders",
                    "documentation": "Optional additional Folder structures for this EHR. If set, the `_directory_` attribute refers to the first member.",
                    "type_def": {
                        "container_type": "List",
                        "type": "OBJECT_REF"
                    },
                    "cardinality": {
                        "lower": 0,
                        "upper_unbounded": true
                    }
                },
                "tags": {
                    "_type": "P_BMM_CONTAINER_PROPERTY",
                    "name": "tags",
                    "documentation": "Optional list of tags associated with this EHR. Tag `_target_` values can only be within the same EHR.",
                    "type_def": {
                        "container_type": "List",
                        "type": "OBJECT_REF"
                    },
                    "cardinality": {
                        "lower": 0,
                        "upper_unbounded": true
                    }
                }
            },
            "invariants": {
                "Contributions_valid": "for_all c in contributions | c.type.is_equal(\"CONTRIBUTION\")",
                "Ehr_access_valid": "ehr_access.type.is_equal (\"VERSIONED_EHR_ACCESS\")",
                "Ehr_status_valid": "ehr_status.type.is_equal(\"VERSIONED_EHR_STATUS\")",
                "Compositions_valid": "for_all c in compositions | c.type.is_equal (\"VERSIONED_COMPOSITION\")",
                "Directory_valid": "directory \/= Void implies directory.type.is_equal (\"VERSIONED_FOLDER\")",
                "Folders_valid": "folders \/= Void implies for_all f in folders | f.type.is_equal(\"VERSIONED_FOLDER\")",
                "Directory_in_folders": "folders \/= Void implies folders.item(1) = directory"
            }
        },
        "VERSIONED_EHR_ACCESS": {
            "name": "VERSIONED_EHR_ACCESS",
            "documentation": "Version container for `EHR_ACCESS` instance.",
            "ancestors": [
                "VERSIONED_OBJECT"
            ]
        },
        "VERSIONED_EHR_STATUS": {
            "name": "VERSIONED_EHR_STATUS",
            "documentation": "Version container for `EHR_STATUS` instance.",
            "ancestors": [
                "VERSIONED_OBJECT"
            ]
        },
        "VERSIONED_COMPOSITION": {
            "name": "VERSIONED_COMPOSITION",
            "documentation": "Version-controlled composition abstraction, defined by inheriting `VERSIONED_OBJECT<COMPOSITION>`. ",
            "ancestors": [
                "VERSIONED_OBJECT"
            ],
            "functions": {
                "is_persistent": {
                    "name": "is_persistent",
                    "documentation": "Indicates whether this composition set is persistent; derived from first version.",
                    "result": {
                        "type": "Boolean"
                    }
                }
            },
            "invariants": {
                "Archetype_node_id_valid": "for_all v in all_versions | v.archetype_node_id.is_equal (all_versions.first.archetype_node_id)",
                "Persistent_validity": "for_all v in all_versions | v.is_persistent = all_versions.first.data.is_persistent"
            }
        },
        "EHR_ACCESS": {
            "name": "EHR_ACCESS",
            "documentation": "EHR-wide access control object. All access decisions to data in the EHR must be made in accordance with the policies and rules in this object.\n\nNOTE: It is strongly recommended that the inherited attribute `_uid_` be populated in `EHR_ACCESS` objects, using the UID copied from the `_object_id()_` of the `_uid_` field of the enclosing `VERSION` object. +\nFor example, the `ORIGINAL_VERSION.uid` `87284370-2D4B-4e3d-A3F3-F303D2F4F34B::uk.nhs.ehr1::2` would be copied to the `_uid_` field of the `EHR_ACCESS` object.",
            "ancestors": [
                "LOCATABLE"
            ],
            "properties": {
                "settings": {
                    "name": "settings",
                    "documentation": "Access control settings for the EHR. Instance is a subtype of the type `ACCESS_CONTROL_SETTINGS`, allowing for the use of different access control schemes. ",
                    "type": "ACCESS_CONTROL_SETTINGS"
                }
            },
            "functions": {
                "scheme": {
                    "name": "scheme",
                    "documentation": "The name of the access control scheme in use; corresponds to the concrete instance of the settings attribute. ",
                    "result": {
                        "type": "String"
                    }
                }
            },
            "invariants": {
                "Scheme_valid": "not scheme.is_empty",
                "Is_archetype_root": "is_archetype_root"
            }
        },
        "EHR_STATUS": {
            "name": "EHR_STATUS",
            "documentation": "Single object per EHR containing various EHR-wide status flags and settings, including whether this EHR can be queried, modified etc. This object is always modifiable, in order to change the status of the EHR as a whole.\n\nNOTE: It is strongly recommended that the inherited attribute `_uid_` be populated in `EHR_STATUS` objects, using the UID copied from the `_object_id()_` of the `_uid_` field of the enclosing `VERSION` object. +\nFor example, the `ORIGINAL_VERSION.uid` `87284370-2D4B-4e3d-A3F3-F303D2F4F34B::uk.nhs.ehr1::2`  would be copied to the `_uid_` field of the `EHR_STATUS` object.",
            "ancestors": [
                "LOCATABLE"
            ],
            "properties": {
                "subject": {
                    "name": "subject",
                    "documentation": "The subject of this EHR. The `_external_ref_` attribute can be used to contain a direct reference to the subject in a demographic or identity service. Alternatively, the association between patients and their records may be done elsewhere for security reasons. ",
                    "is_mandatory": true,
                    "type": "PARTY_SELF"
                },
                "is_queryable": {
                    "name": "is_queryable",
                    "documentation": "True if this EHR should be included in population queries, i.e. if this EHR is considered active in the population.",
                    "is_mandatory": true,
                    "type": "Boolean"
                },
                "is_modifiable": {
                    "name": "is_modifiable",
                    "documentation": "True if the EHR, other than the `EHR_STATUS` object, is allowed to be written to. The `EHR_STATUS` object itself can always be written to.",
                    "is_mandatory": true,
                    "type": "Boolean"
                },
                "other_details": {
                    "name": "other_details",
                    "documentation": "Any other details of the EHR summary object, in the form of an archetyped `ITEM_STRUCTURE`.",
                    "type": "ITEM_STRUCTURE"
                }
            },
            "invariants": {
                "Is_archetype_root": "is_archetype_root"
            }
        },
        "ACCESS_CONTROL_SETTINGS": {
            "name": "ACCESS_CONTROL_SETTINGS",
            "documentation": "Access Control Settings for the EHR and components. Intended to support multiple access control schemes. Currently implementation dependent.",
            "is_abstract": true
        },
        "EXTRACT": {
            "name": "EXTRACT",
            "documentation": "Generic model of an Extract of some information from a repository.",
            "ancestors": [
                "LOCATABLE"
            ],
            "properties": {
                "chapters": {
                    "_type": "P_BMM_CONTAINER_PROPERTY",
                    "name": "chapters",
                    "documentation": "The content extracted and serialised from the source repository for this Extract.",
                    "type_def": {
                        "container_type": "List",
                        "type": "EXTRACT_CHAPTER"
                    },
                    "cardinality": {
                        "lower": 0,
                        "upper_unbounded": true
                    }
                },
                "specification": {
                    "name": "specification",
                    "documentation": "The specification that this Extract actually conforms to; might not be identical with the specification of the corresponding request.",
                    "type": "EXTRACT_SPEC"
                },
                "request_id": {
                    "name": "request_id",
                    "documentation": "Reference to causing Request, if any.",
                    "type": "HIER_OBJECT_ID"
                },
                "time_created": {
                    "name": "time_created",
                    "documentation": "Creation time of this Extract",
                    "is_mandatory": true,
                    "type": "DV_DATE_TIME"
                },
                "system_id": {
                    "name": "system_id",
                    "documentation": "Identifier of creating system.",
                    "is_mandatory": true,
                    "type": "HIER_OBJECT_ID"
                },
                "sequence_nr": {
                    "name": "sequence_nr",
                    "documentation": "Number of this Extract response in sequence of responses to Extract request identified by `_request_id_`. If this is the sole response, or there was no request, value is 1.",
                    "is_mandatory": true,
                    "type": "Integer"
                },
                "participations": {
                    "_type": "P_BMM_CONTAINER_PROPERTY",
                    "name": "participations",
                    "documentation": "Participations relevant to the creation of this Extract.",
                    "type_def": {
                        "container_type": "List",
                        "type": "EXTRACT_PARTICIPATION"
                    },
                    "cardinality": {
                        "lower": 0,
                        "upper_unbounded": true
                    }
                }
            },
            "invariants": {
                "Sequence_nr_valid": "sequence_nr >= 1"
            }
        },
        "EXTRACT_ACTION_REQUEST": {
            "name": "EXTRACT_ACTION_REQUEST",
            "documentation": "Generic model of a Request for an Extract, containing an Extract specification.",
            "ancestors": [
                "LOCATABLE"
            ],
            "properties": {
                "request_id": {
                    "name": "request_id",
                    "documentation": "Identifier of previous `EXTRACT_REQUEST`.",
                    "is_mandatory": true,
                    "type": "OBJECT_REF"
                },
                "uid": {
                    "name": "uid",
                    "is_mandatory": true,
                    "type": "HIER_OBJECT_ID"
                },
                "action": {
                    "name": "action",
                    "documentation": "Requested action: `cancel | resend | send new`. Coded by openEHR Terminology group `'extract action type'`.",
                    "is_mandatory": true,
                    "type": "DV_CODED_TEXT"
                }
            }
        },
        "EXTRACT_CHAPTER": {
            "name": "EXTRACT_CHAPTER",
            "documentation": "One content chapter of an Extract; contains information relating to only one entity.",
            "ancestors": [
                "LOCATABLE"
            ],
            "properties": {
                "items": {
                    "_type": "P_BMM_CONTAINER_PROPERTY",
                    "name": "items",
                    "documentation": "The information content of this chapter.",
                    "type_def": {
                        "container_type": "List",
                        "type": "EXTRACT_ITEM"
                    },
                    "cardinality": {
                        "lower": 0,
                        "upper_unbounded": true
                    }
                }
            }
        },
        "EXTRACT_CONTENT_ITEM": {
            "name": "EXTRACT_CONTENT_ITEM",
            "documentation": "Abstract model of a wrapper for one content item in an Extract, containing various meta-data. Indicates whether it was part of the primary set and what its original path was. Intended to be subtyped for wrappers of specific types of content.",
            "is_abstract": true,
            "ancestors": [
                "EXTRACT_ITEM"
            ],
            "properties": {
                "is_primary": {
                    "name": "is_primary",
                    "documentation": "True if the content item carried in this container was part of the primary set for the Extract, i.e. not added due to link-following.",
                    "is_mandatory": true,
                    "type": "Boolean"
                },
                "is_changed": {
                    "name": "is_changed",
                    "documentation": "True if the content item carried in this container is any kind of change since last send, in repeat sending situations.",
                    "type": "Boolean"
                },
                "is_masked": {
                    "name": "is_masked",
                    "documentation": "True if the content of this item has not been included due to insufficient access rights of requestor.",
                    "type": "Boolean"
                },
                "item": {
                    "name": "item",
                    "documentation": "Content object.",
                    "type": "Any"
                }
            },
            "invariants": {
                "Item_validity": "is_masked xor item \/= Void"
            }
        },
        "EXTRACT_ENTITY_CHAPTER": {
            "name": "EXTRACT_ENTITY_CHAPTER",
            "documentation": "Type of chapter that contains information relating to a single demographic entity.",
            "ancestors": [
                "EXTRACT_CHAPTER"
            ],
            "properties": {
                "extract_id_key": {
                    "name": "extract_id_key",
                    "documentation": "Reference to entity, usually a demographic entity such as a patient that the content of this chapter relates to.",
                    "is_mandatory": true,
                    "type": "String"
                }
            }
        },
        "EXTRACT_ENTITY_MANIFEST": {
            "name": "EXTRACT_ENTITY_MANIFEST",
            "documentation": "The manifest for one entity (e.g. EHR subject), identifying the entity and optionally specifying top-level items to be included in the Extract. The list actually included may be modified by the `_version_spec_` part of the specification, and also by the link_depth attribute. In repeat (standing order) requests, the final inclusion may be modified by the send_changes_only value for `EXTRACT_UPDATE_SPEC._update_method_`.\n\nVarious identifiers may be provided for the entity; these are to be used by the receiver system to locate the entity. The `_extract_id_key_` attribute is used to record the identifier that will be used throughout the Extract for this entity, including in instances of `EXTRACT_ENTITY_IDENTIFIER`.",
            "properties": {
                "extract_id_key": {
                    "name": "extract_id_key",
                    "documentation": "Identifier by which this entity is known in the Extract. May be one of the other identifiers, e.g. ehr_id or subject_id, or it may be something else, including a simple integer.",
                    "is_mandatory": true,
                    "type": "String"
                },
                "ehr_id": {
                    "name": "ehr_id",
                    "documentation": "EHR \/ EMR identifier for the entity at the target system.",
                    "type": "String"
                },
                "subject_id": {
                    "name": "subject_id",
                    "documentation": "Subject (i.e. patient or similar) identifier for the entity at the target system.",
                    "type": "String"
                },
                "other_ids": {
                    "_type": "P_BMM_CONTAINER_PROPERTY",
                    "name": "other_ids",
                    "documentation": "Other identifiers that may be used to find the entity at the target system, keyed by type. May include medicare numbers, drivers license number, tax number etc.",
                    "type_def": {
                        "container_type": "List",
                        "type": "String"
                    },
                    "cardinality": {
                        "lower": 0,
                        "upper_unbounded": true
                    }
                },
                "item_list": {
                    "_type": "P_BMM_CONTAINER_PROPERTY",
                    "name": "item_list",
                    "documentation": "List of Uids of items to be included in the Extract, in cases where individual items are being requested by id. More typically, this attribute is not used, and the `EXTRACT_SPEC._criteria query_` defines the Extract contents. If set, for openEHR data, these are Uids identifying the version containers.",
                    "type_def": {
                        "container_type": "List",
                        "type": "OBJECT_REF"
                    },
                    "cardinality": {
                        "lower": 0,
                        "upper_unbounded": true
                    }
                }
            }
        },
        "EXTRACT_ERROR": {
            "name": "EXTRACT_ERROR",
            "properties": {
                "request_id": {
                    "name": "request_id",
                    "type": "OBJECT_REF"
                },
                "reason": {
                    "name": "reason",
                    "is_mandatory": true,
                    "type": "DV_TEXT"
                }
            }
        },
        "EXTRACT_FOLDER": {
            "name": "EXTRACT_FOLDER",
            "documentation": "Folder in local Folder structure in an Extract. Empty Folders are allowed.",
            "ancestors": [
                "EXTRACT_ITEM"
            ],
            "properties": {
                "items": {
                    "_type": "P_BMM_CONTAINER_PROPERTY",
                    "name": "items",
                    "documentation": "List of Folders and content items in this Folder.",
                    "type_def": {
                        "container_type": "List",
                        "type": "EXTRACT_ITEM"
                    },
                    "cardinality": {
                        "lower": 0,
                        "upper_unbounded": true
                    }
                }
            }
        },
        "EXTRACT_ITEM": {
            "name": "EXTRACT_ITEM",
            "documentation": "Abstract parent of Extract Folder and Content types.",
            "is_abstract": true,
            "ancestors": [
                "LOCATABLE"
            ]
        },
        "EXTRACT_MANIFEST": {
            "name": "EXTRACT_MANIFEST",
            "documentation": "Specification of the candidate entities and optionally top-level items (e.g. Compositions) to be included in the Extract.",
            "properties": {
                "entities": {
                    "_type": "P_BMM_CONTAINER_PROPERTY",
                    "name": "entities",
                    "documentation": "List of entity manifests uids of items included in the Extract; for openEHR data, these are uids identifying the version containers.",
                    "is_mandatory": true,
                    "type_def": {
                        "container_type": "List",
                        "type": "EXTRACT_ENTITY_MANIFEST"
                    },
                    "cardinality": {
                        "lower": 1,
                        "upper_unbounded": true
                    }
                }
            }
        },
        "EXTRACT_PARTICIPATION": {
            "name": "EXTRACT_PARTICIPATION",
            "documentation": "Model of a participation of a Party (any Actor or Role) in an activity.  Used to represent any participation of a Party in some activity, which is not  explicitly in the model, e.g. assisting nurse. Can be used to record past or  future participations.\n\nShould not be used in place of more permanent relationships between demographic entities. ",
            "properties": {
                "time": {
                    "_type": "P_BMM_GENERIC_PROPERTY",
                    "name": "time",
                    "documentation": "The time interval during which the participation took place, if it is used in an observational context (i.e. recording facts about the past); or the intended time interval of the participation when used in future contexts, such as EHR Instructions. ",
                    "type_def": {
                        "root_type": "DV_INTERVAL",
                        "generic_parameters": [
                            "DV_DATE_TIME"
                        ]
                    }
                },
                "function": {
                    "name": "function",
                    "documentation": "The function of the Party in this participation (note that a given party might participate in more than one way in a particular activity). This attribute should be coded, but cannot be limited to the HL7v3:ParticipationFunction vocabulary, since it is too limited and hospital-oriented. ",
                    "is_mandatory": true,
                    "type": "DV_TEXT"
                },
                "mode": {
                    "name": "mode",
                    "documentation": "The mode of the performer \/ activity interaction, e.g. present, by telephone, by email etc. ",
                    "type": "DV_CODED_TEXT"
                },
                "performer": {
                    "name": "performer",
                    "documentation": "Uid of demographic entity within Extract who performed this participation.",
                    "is_mandatory": true,
                    "type": "String"
                }
            },
            "invariants": {
                "Function_valid": "function \/= Void and then function.generating_type.is_equal (\u201cDV_CODED_TEXT\u201d) implies terminology (Terminology_id_openehr).has_code_for_group_id (Group_id_participation_function, function.defining_code)",
                "Mode_valid": "mode \/= Void and terminology (Terminology_id_openehr).has_code_for_group_id (Group_id_participation_mode, mode.defining_code)"
            }
        },
        "EXTRACT_REQUEST": {
            "name": "EXTRACT_REQUEST",
            "documentation": "Generic model of a Request for an Extract, containing an Extract specification.",
            "ancestors": [
                "LOCATABLE"
            ],
            "properties": {
                "extract_spec": {
                    "name": "extract_spec",
                    "documentation": "Specification details of the request.",
                    "is_mandatory": true,
                    "type": "EXTRACT_SPEC"
                },
                "update_spec": {
                    "name": "update_spec",
                    "documentation": "Update details of the request.",
                    "type": "EXTRACT_UPDATE_SPEC"
                },
                "uid": {
                    "name": "uid",
                    "documentation": "Identifier of this Request, generated by requestor.",
                    "is_mandatory": true,
                    "type": "HIER_OBJECT_ID"
                }
            }
        },
        "EXTRACT_SPEC": {
            "name": "EXTRACT_SPEC",
            "documentation": "Specification of an Extract's contents. Subtypes can be used to add details specific to the type of Extract. The specification consists of attributes specifying the directory, and two further groups of attributes in their own classes, namely a version specfication (which versions of information items are to be included) and a manifest (which entities are to be included in the extract).\n\nUse: Used in a request to specify an Extract, as well as to describe what is contained in an Extract.",
            "properties": {
                "version_spec": {
                    "name": "version_spec",
                    "documentation": "Specification of which versions of information items to include in the Extract. If Void, the default is latest versions only (which is reasonable for non-versioning systems as well).",
                    "type": "EXTRACT_VERSION_SPEC"
                },
                "manifest": {
                    "name": "manifest",
                    "documentation": "Specification of entities (e.g. records) to include in the Extract.",
                    "is_mandatory": true,
                    "type": "EXTRACT_MANIFEST"
                },
                "extract_type": {
                    "name": "extract_type",
                    "documentation": "Coded term indicating the type of content required, e.g.\n\n* `|openehr-ehr|`\n* `|openehr-demographic|`\n* `|generic-emr|`\n* `|other|`\n\nCoded by openEHR Terminology group `'extract content type'`.",
                    "is_mandatory": true,
                    "type": "DV_CODED_TEXT"
                },
                "include_multimedia": {
                    "name": "include_multimedia",
                    "documentation": "Indicates whether in-line instances of `DV_MULTIMEDIA` in the source data are included or not.",
                    "is_mandatory": true,
                    "type": "Boolean"
                },
                "priority": {
                    "name": "priority",
                    "documentation": "Requested priority of this request to be handled by server. Priority schemes are likely to be local, and use values agreed by both ends.\n\nTBD: alternative is standard coded terms",
                    "is_mandatory": true,
                    "type": "Integer"
                },
                "link_depth": {
                    "name": "link_depth",
                    "documentation": "Degree of links to follow emanating from content items specified for inclusion. The kind of links to follow is dependent on the type of Extract.\n\nAll items at the target end of followed links at the given depth are also included in the extract; `EXTRACT_CONTENT_ITEM._is_primary_` is used to differentiate.\n\n* 0 = don't follow;\n* 1 = follow first degree links;\n* 2 = follow 2nd degree links;\n* ....\n* n = follow nth degree links\n",
                    "is_mandatory": true,
                    "type": "Integer"
                },
                "criteria": {
                    "_type": "P_BMM_CONTAINER_PROPERTY",
                    "name": "criteria",
                    "documentation": "Queries specifying the contents of this Extract.",
                    "type_def": {
                        "container_type": "List",
                        "type": "DV_PARSABLE"
                    },
                    "cardinality": {
                        "lower": 0,
                        "upper_unbounded": true
                    }
                },
                "other_details": {
                    "name": "other_details",
                    "documentation": "Other specification items. Archetypable.",
                    "type": "ITEM_STRUCTURE"
                }
            }
        },
        "EXTRACT_UPDATE_SPEC": {
            "name": "EXTRACT_UPDATE_SPEC",
            "documentation": "Specification of the how the request should be processed by server. The request can be persisted in the server, meaning that a) it can be re-activated by the requesting system simply by indicating Request id, and b) that a changes-only pattern of Extract updates can be set up. To achieve this, the server has to remember what was sent in the previous response.\n\nThe update mode may be event-driven and periodic update or a mixture of both. The candidate items to be sent each time are the result of re-evaluating the content and versioning parts of the specification; what is actually sent is determined by the `_send_changes_only_` flag.",
            "properties": {
                "persist_in_server": {
                    "name": "persist_in_server",
                    "documentation": "If True, this Request is persisted in the server until further notice.",
                    "is_mandatory": true,
                    "type": "Boolean"
                },
                "repeat_period": {
                    "name": "repeat_period",
                    "documentation": "Period for resending update Extracts in response to original Request.",
                    "type": "DV_DURATION"
                },
                "trigger_events": {
                    "_type": "P_BMM_CONTAINER_PROPERTY",
                    "name": "trigger_events",
                    "documentation": "Set of Event names that will cause sending of update Extracts. Event types include:   \n\n* `|any_change|` - any change in content items matched by content specification, e.g. new versions of persistent compositions. If the content list allows matching of any, or a wide range of archetypes, this event type will match any additions to the record.\n* `|correction|` - match error corrections only, including deletions.\n* `|update|` - match updates (i.e. new versions) of included content items.\n\nCoded by openEHR Terminology group 'extract update trigger event type'.",
                    "type_def": {
                        "container_type": "List",
                        "type": "DV_CODED_TEXT"
                    },
                    "cardinality": {
                        "lower": 0,
                        "upper_unbounded": true
                    }
                },
                "update_method": {
                    "name": "update_method",
                    "documentation": "Indicate mode of update. Can be: send only items that are changed (including logical deletions) or new since last send. For `_persist_in_server_` Requests only.",
                    "is_mandatory": true,
                    "type": "CODE_PHRASE"
                }
            },
            "invariants": {
                "Overall_validity": "repeat_period \/= Void or trigger_events \/= Void",
                "Trigger_events_validity": "trigger_events \/= Void implies not trigger_events.is_empty",
                "Send_changes_only_validity": "send_changes_only implies persist_in_server"
            }
        },
        "EXTRACT_VERSION_SPEC": {
            "name": "EXTRACT_VERSION_SPEC",
            "documentation": "Specification of what versions should be included in an Extract. By default, only latest versions are included in the Extract, in which case this part of the Extract specification is not needed at all. The attributes `_include_all_versions_` and `_commit_time_interval_` are used to modify this; the former forces all versions to be included; the latter limits the versions to be those latest versions committed in the time interval, or if `_include_all_versions_` is `True`, all versions committed in the time interval.",
            "properties": {
                "include_all_versions": {
                    "name": "include_all_versions",
                    "documentation": "True if all versions of each item in the Extract are included.",
                    "is_mandatory": true,
                    "type": "Boolean"
                },
                "commit_time_interval": {
                    "_type": "P_BMM_GENERIC_PROPERTY",
                    "name": "commit_time_interval",
                    "documentation": "Specifies commit time interval of items to source repository to include in Extract. By default, only latest versions whose commit times fall in the range are included. If include_all_versions is True, then the range includes all versions committed within the interval.",
                    "type_def": {
                        "root_type": "DV_INTERVAL",
                        "generic_parameters": [
                            "DV_DATE_TIME"
                        ]
                    }
                },
                "include_revision_history": {
                    "name": "include_revision_history",
                    "documentation": "True if revision histories of the items in the Extract are included. If included, it is always the full revision history.",
                    "is_mandatory": true,
                    "type": "Boolean"
                },
                "include_data": {
                    "name": "include_data",
                    "documentation": "`True` if the data of items matched by the content spec should be included. This is the default. If `False`, only revision history is included in serialised versions. Turning this option on in openEHR systems causes `X_VERSIONED_OBJECTs` to have `_revision_history_` set, but versions Void. Useful for interrogating a server without having to look at any content data. In other systems it may or may not have a sensible meaning.",
                    "is_mandatory": true,
                    "type": "Boolean"
                }
            },
            "invariants": {
                "Includes_revision_history_valid": "not include_data implies include_revision_history"
            }
        },
        "OPENEHR_CONTENT_ITEM": {
            "name": "OPENEHR_CONTENT_ITEM",
            "documentation": "Form of `EHR EXTRACT_ITEM` containing openEHR serialised `VERSIONED_OBJECTs`.",
            "ancestors": [
                "EXTRACT_CONTENT_ITEM"
            ],
            "properties": {
                "item": {
                    "name": "item",
                    "documentation": "Content object.",
                    "type": "X_VERSIONED_OBJECT"
                }
            }
        },
        "X_VERSIONED_OBJECT": {
            "name": "X_VERSIONED_OBJECT",
            "documentation": "Variety of Extract content that consists is a sharable data-oriented version of `VERSIONED_OBJECT<T>`.",
            "generic_parameter_defs": {
                "T": {
                    "name": "T"
                }
            },
            "properties": {
                "uid": {
                    "name": "uid",
                    "documentation": "Uid of original `VERSIONED_OBJECT`.",
                    "is_mandatory": true,
                    "type": "HIER_OBJECT_ID"
                },
                "owner_id": {
                    "name": "owner_id",
                    "documentation": "Owner_id from original `VERSIONED_OBJECT`, which identifies source EHR.",
                    "is_mandatory": true,
                    "type": "OBJECT_REF"
                },
                "time_created": {
                    "name": "time_created",
                    "documentation": "Creation time of original `VERSIONED_OBJECT`.",
                    "is_mandatory": true,
                    "type": "DV_DATE_TIME"
                },
                "total_version_count": {
                    "name": "total_version_count",
                    "documentation": "Total number of versions in original `VERSIONED_OBJECT` at time of creation of this `X_VERSIONED_OBJECT`.",
                    "is_mandatory": true,
                    "type": "Integer"
                },
                "extract_version_count": {
                    "name": "extract_version_count",
                    "documentation": "The number of Versions in this extract for this Versioned object, i.e. the count of items in the versions attribute. May be 0 if only revision history is requested.",
                    "is_mandatory": true,
                    "type": "Integer"
                },
                "revision_history": {
                    "name": "revision_history",
                    "documentation": "Optional revision history of the original `VERSIONED_OBJECT`. If included, it is the complete revision history.",
                    "type": "REVISION_HISTORY"
                },
                "versions": {
                    "_type": "P_BMM_CONTAINER_PROPERTY",
                    "name": "versions",
                    "documentation": "0 or more Versions from the original `VERSIONED_OBJECT`, according to the Extract specification.",
                    "type_def": {
                        "container_type": "List",
                        "type_def": {
                            "_type": "P_BMM_GENERIC_TYPE",
                            "root_type": "ORIGINAL_VERSION",
                            "generic_parameters": [
                                "T"
                            ]
                        }
                    },
                    "cardinality": {
                        "lower": 0,
                        "upper_unbounded": true
                    }
                }
            }
        },
        "X_VERSIONED_EHR_ACCESS": {
            "name": "X_VERSIONED_EHR_ACCESS",
            "documentation": "Form of `X_VERSIONED_OBJECT` for `EHR_ACCESS` EHR object.",
            "ancestors": [
                "X_VERSIONED_OBJECT"
            ]
        },
        "X_VERSIONED_EHR_STATUS": {
            "name": "X_VERSIONED_EHR_STATUS",
            "documentation": "Form of `X_VERSIONED_OBJECT` for `EHR_STATUS` EHR object.",
            "ancestors": [
                "X_VERSIONED_OBJECT"
            ]
        },
        "X_VERSIONED_COMPOSITION": {
            "name": "X_VERSIONED_COMPOSITION",
            "documentation": "Form of `X_VERSIONED_OBJECT` for `COMPOSITION` EHR object.",
            "ancestors": [
                "X_VERSIONED_OBJECT"
            ]
        },
        "X_VERSIONED_FOLDER": {
            "name": "X_VERSIONED_FOLDER",
            "documentation": "Form of `X_VERSIONED_OBJECT` for `FOLDER` EHR object.",
            "ancestors": [
                "X_VERSIONED_OBJECT"
            ]
        },
        "X_VERSIONED_PARTY": {
            "name": "X_VERSIONED_PARTY",
            "documentation": "Form of `X_VERSIONED_OBJECT` for `PARTY` demographic object.",
            "ancestors": [
                "X_VERSIONED_OBJECT"
            ]
        },
        "GENERIC_CONTENT_ITEM": {
            "name": "GENERIC_CONTENT_ITEM",
            "documentation": "Single item in generic extract, designed for 13606 and CDA data.",
            "ancestors": [
                "EXTRACT_CONTENT_ITEM"
            ],
            "properties": {
                "item_type": {
                    "name": "item_type",
                    "documentation": "Identifier of model or schema used to create the content.",
                    "type": "DV_CODED_TEXT"
                },
                "item_type_version": {
                    "name": "item_type_version",
                    "documentation": "Version of model or schema used to create the content item.",
                    "type": "String"
                },
                "author": {
                    "name": "author",
                    "documentation": "Reference to a demographic entity elsewhere in this Extract representing the author of the item version. The reference should be a UID corresponding to the UID of a `GENERIC_CONTENT_ITEM` containing the demographic information.",
                    "type": "String"
                },
                "creation_time": {
                    "name": "creation_time",
                    "documentation": "Time of creation of this item version on the original system. This may be an earlier commit time, or it may be the time at which the item was created during the Extract generation process.",
                    "type": "Iso8601_date_time"
                },
                "authoriser": {
                    "name": "authoriser",
                    "documentation": "Reference to a demographic entity elsewhere in this Extract representing an authoriser of the item version, if relevant. The reference should be a UID corresponding to the UID of a `GENERIC_CONTENT_ITEM` containing the demographic information.",
                    "type": "String"
                },
                "authorisation_time": {
                    "name": "authorisation_time",
                    "documentation": "Time of authorisation of this item version on the original system where relevant.",
                    "type": "Iso8601_date_time"
                },
                "item_status": {
                    "name": "item_status",
                    "documentation": "Coded lifecycle status of the item.",
                    "type": "DV_CODED_TEXT"
                },
                "version_id": {
                    "name": "version_id",
                    "documentation": "Version id of this item in original system.",
                    "type": "String"
                },
                "version_set_id": {
                    "name": "version_set_id",
                    "documentation": "Version set id of this item in original system, where applicable.",
                    "type": "String"
                },
                "system_id": {
                    "name": "system_id",
                    "documentation": "Identifier of EMR or other system from which the item was created \/ extracted. Typically in the form of a domain name.",
                    "type": "String"
                },
                "other_details": {
                    "_type": "P_BMM_GENERIC_PROPERTY",
                    "name": "other_details",
                    "documentation": "Other details about the content item.",
                    "type_def": {
                        "root_type": "Hash",
                        "generic_parameters": [
                            "String",
                            "String"
                        ]
                    }
                },
                "item": {
                    "name": "item",
                    "documentation": "Content object.",
                    "type": "LOCATABLE"
                }
            }
        },
        "SYNC_EXTRACT_REQUEST": {
            "name": "SYNC_EXTRACT_REQUEST",
            "documentation": "Type of request designed for synchronisation of Contributions between openEHR servers.",
            "ancestors": [
                "MESSAGE_CONTENT"
            ],
            "properties": {
                "specification": {
                    "name": "specification",
                    "documentation": "Details of specification of synchronisation request.",
                    "is_mandatory": true,
                    "type": "SYNC_EXTRACT_SPEC"
                }
            }
        },
        "SYNC_EXTRACT": {
            "name": "SYNC_EXTRACT",
            "ancestors": [
                "MESSAGE_CONTENT"
            ],
            "properties": {
                "specification": {
                    "name": "specification",
                    "documentation": "Details of specification of this Extract.",
                    "is_mandatory": true,
                    "type": "SYNC_EXTRACT_SPEC"
                },
                "items": {
                    "_type": "P_BMM_CONTAINER_PROPERTY",
                    "name": "items",
                    "documentation": "Content, in the form of a serialised Contributions.",
                    "type_def": {
                        "container_type": "List",
                        "type": "X_CONTRIBUTION"
                    },
                    "cardinality": {
                        "lower": 0,
                        "upper_unbounded": true
                    }
                }
            }
        },
        "X_CONTRIBUTION": {
            "name": "X_CONTRIBUTION",
            "documentation": "Serialised form of Contribution for an Extract.",
            "properties": {
                "uid": {
                    "name": "uid",
                    "documentation": "Uid of Contribution in source system.",
                    "is_mandatory": true,
                    "type": "HIER_OBJECT_ID"
                },
                "audit": {
                    "name": "audit",
                    "documentation": "Audit of Contribution in source system.",
                    "is_mandatory": true,
                    "type": "AUDIT_DETAILS"
                },
                "versions": {
                    "_type": "P_BMM_CONTAINER_PROPERTY",
                    "name": "versions",
                    "documentation": "Serialised Versions from Contribution in source system.",
                    "type_def": {
                        "container_type": "List",
                        "type_def": {
                            "_type": "P_BMM_GENERIC_TYPE",
                            "root_type": "VERSION",
                            "generic_parameters": [
                                "X_CONTRIBUTION"
                            ]
                        }
                    },
                    "cardinality": {
                        "lower": 0,
                        "upper_unbounded": true
                    }
                }
            }
        },
        "SYNC_EXTRACT_SPEC": {
            "name": "SYNC_EXTRACT_SPEC",
            "documentation": "Details of specification of Extract, used in a request to specify an Extract, or in a response, to describe what is actually in the Extract.",
            "properties": {
                "includes_versions": {
                    "name": "includes_versions",
                    "documentation": "True if the Versions from the Contribution are included; False if just the Contribution and its Audit are included.",
                    "is_mandatory": true,
                    "type": "Boolean"
                },
                "contribution_list": {
                    "_type": "P_BMM_CONTAINER_PROPERTY",
                    "name": "contribution_list",
                    "documentation": "List of Contributions to include \/ that are included in the Extract.",
                    "type_def": {
                        "container_type": "List",
                        "type": "HIER_OBJECT_ID"
                    },
                    "cardinality": {
                        "lower": 0,
                        "upper_unbounded": true
                    }
                },
                "contributions_since": {
                    "name": "contributions_since",
                    "documentation": "Specify Contributions included in Extract by threshold date.",
                    "type": "DV_DATE_TIME"
                },
                "all_contributions": {
                    "name": "all_contributions",
                    "documentation": "True if all Contributions in the record are included.",
                    "type": "Boolean"
                }
            }
        },
        "MESSAGE": {
            "name": "MESSAGE",
            "documentation": "A \u201cmessage\u201d is an authored, possibly signed, piece of content intended for one or more recipients. Since the recipient may or may not be known directly, recipients are specified in the `ADDRESSED_MESSAGE` class.",
            "properties": {
                "audit": {
                    "name": "audit",
                    "documentation": "Details of who actually created the message and when. This is the person who entered the data or otherwise caused the message to be created, or might be a piece of software.",
                    "is_mandatory": true,
                    "type": "AUDIT_DETAILS"
                },
                "author": {
                    "name": "author",
                    "documentation": "Party responsible for the message content, who may or may not be technically responsible for its creation (e.g. by data entry etc).",
                    "is_mandatory": true,
                    "type": "PARTY_PROXY"
                },
                "content": {
                    "name": "content",
                    "documentation": "Content of the message.",
                    "is_mandatory": true,
                    "type": "MESSAGE_CONTENT"
                },
                "signature": {
                    "name": "signature",
                    "documentation": "Optional signature by the author of message content in openPGP format. The signature is created as a Hash and optional signing of the serialisation of this message object with this signature field Void.",
                    "type": "String"
                }
            }
        },
        "ADDRESSED_MESSAGE": {
            "name": "ADDRESSED_MESSAGE",
            "documentation": "The concept of a message addressed to nominated recipients.",
            "properties": {
                "sender": {
                    "name": "sender",
                    "documentation": "Party sending the message.",
                    "is_mandatory": true,
                    "type": "String"
                },
                "sender_reference": {
                    "name": "sender_reference",
                    "documentation": "Identification of message used by sender. This will be the same no matter how many times this message is sent to these recipients.",
                    "is_mandatory": true,
                    "type": "String"
                },
                "addressees": {
                    "_type": "P_BMM_CONTAINER_PROPERTY",
                    "name": "addressees",
                    "documentation": "Intended recipients, in the form of internet addresses.",
                    "is_mandatory": true,
                    "type_def": {
                        "container_type": "List",
                        "type": "String"
                    },
                    "cardinality": {
                        "lower": 1,
                        "upper_unbounded": true
                    }
                },
                "urgency": {
                    "name": "urgency",
                    "documentation": "Urgency with which destination should deal with message:\n\n* -1 - low\n* 0 - normal\n* 1 - high",
                    "type": "Integer"
                },
                "message": {
                    "name": "message",
                    "documentation": "The content of the message.",
                    "is_mandatory": true,
                    "type": "MESSAGE"
                }
            }
        },
        "MESSAGE_CONTENT": {
            "name": "MESSAGE_CONTENT",
            "documentation": "Abstract parent of message payload types.",
            "is_abstract": true
        },
        "PARTY": {
            "name": "PARTY",
            "documentation": "Ancestor of all Party types, including real world entities and their roles. A Party is any entity which can participate in an activity. The `_name_` attribute inherited from `LOCATABLE` is used to indicate the actual type of party (note that the actual names, i.e. identities of parties are indicated in the `_identities_` attribute, not the `_name_` attribute).\n\nNOTE: It is strongly recommended that the inherited attribute `_uid_` be populated in `PARTY` objects, using the UID copied from the `_object_id()_` of the `_uid_` field of the enclosing `VERSION` object. +\nFor example, the `ORIGINAL_VERSION.uid` `87284370-2D4B-4e3d-A3F3-F303D2F4F34B::uk.nhs.ehr1::2`  would be copied to the `_uid_` field of the `PARTY` object.",
            "is_abstract": true,
            "ancestors": [
                "LOCATABLE"
            ],
            "properties": {
                "identities": {
                    "_type": "P_BMM_CONTAINER_PROPERTY",
                    "name": "identities",
                    "documentation": "Identities used by the party to identify itself, such as legal name, stage names, aliases, nicknames and so on.",
                    "is_mandatory": true,
                    "type_def": {
                        "container_type": "List",
                        "type": "PARTY_IDENTITY"
                    },
                    "cardinality": {
                        "lower": 1,
                        "upper_unbounded": true
                    }
                },
                "contacts": {
                    "_type": "P_BMM_CONTAINER_PROPERTY",
                    "name": "contacts",
                    "documentation": "Contacts for this party.",
                    "type_def": {
                        "container_type": "List",
                        "type": "CONTACT"
                    },
                    "cardinality": {
                        "lower": 0,
                        "upper_unbounded": true
                    }
                },
                "details": {
                    "name": "details",
                    "documentation": "All other details for this Party.",
                    "type": "ITEM_STRUCTURE"
                },
                "reverse_relationships": {
                    "_type": "P_BMM_CONTAINER_PROPERTY",
                    "name": "reverse_relationships",
                    "documentation": "References to relationships in which this Party takes part as target.",
                    "type_def": {
                        "container_type": "List",
                        "type": "LOCATABLE_REF"
                    },
                    "cardinality": {
                        "lower": 0,
                        "upper_unbounded": true
                    }
                },
                "relationships": {
                    "_type": "P_BMM_CONTAINER_PROPERTY",
                    "name": "relationships",
                    "documentation": "Relationships in which this Party takes part as source.",
                    "type_def": {
                        "container_type": "List",
                        "type": "PARTY_RELATIONSHIP"
                    },
                    "cardinality": {
                        "lower": 0,
                        "upper_unbounded": true
                    }
                }
            },
            "functions": {
                "type": {
                    "name": "type",
                    "documentation": "Type of party, such as  `PERSON`,  `ORGANISATION`, etc. Role name, e.g.  general practitioner ,  nurse ,  private citizen . Taken from inherited `_name_` attribute.",
                    "result": {
                        "type": "DV_TEXT"
                    }
                }
            },
            "invariants": {
                "Type_valid": "type = name",
                "Identities_valid": "not identities.is_empty",
                "Contacts_valid": "contacts \/= Void implies not contacts.is_empty",
                "Relationships_validity": "relationships \/= Void implies (not relationships.is_empty and then relationships.for_all (r | r.source = self)",
                "Reverse_relationships_validity": "reverse_relationships \/= Void implies (not reverse_relationships.empty and then reverse_relationships.for_all (item | repository (\"demographics\").all_party_relationships.has_object (item) and then repository(\"demographics\").all_party_relationships.object (item).target = self))",
                "Is_archetype_root": "is_archetype_root",
                "Uid_mandatory": "uid \/= Void"
            }
        },
        "CONTACT": {
            "name": "CONTACT",
            "documentation": "Description of a means of contact of a Party. Actual structure is archetyped.",
            "ancestors": [
                "LOCATABLE"
            ],
            "properties": {
                "addresses": {
                    "_type": "P_BMM_CONTAINER_PROPERTY",
                    "name": "addresses",
                    "documentation": "A set of address alternatives for this contact purpose and time validity combination.",
                    "is_mandatory": true,
                    "type_def": {
                        "container_type": "List",
                        "type": "ADDRESS"
                    },
                    "cardinality": {
                        "lower": 1,
                        "upper_unbounded": true
                    }
                },
                "time_validity": {
                    "_type": "P_BMM_GENERIC_PROPERTY",
                    "name": "time_validity",
                    "documentation": "Valid time interval for this contact descriptor.",
                    "type_def": {
                        "root_type": "DV_INTERVAL",
                        "generic_parameters": [
                            "DV_DATE"
                        ]
                    }
                }
            },
            "functions": {
                "purpose": {
                    "name": "purpose",
                    "documentation": "Purpose for which this contact is used, e.g. mail,  daytime phone, etc. Taken from value of inherited `_name_` attribute.",
                    "result": {
                        "type": "DV_TEXT"
                    }
                }
            },
            "invariants": {
                "Purpose_valid": "purpose = name"
            }
        },
        "ADDRESS": {
            "name": "ADDRESS",
            "documentation": "Address of contact, which may be electronic or geographic.",
            "ancestors": [
                "LOCATABLE"
            ],
            "properties": {
                "details": {
                    "name": "details",
                    "documentation": "Archetypable structured address.",
                    "is_mandatory": true,
                    "type": "ITEM_STRUCTURE"
                }
            },
            "functions": {
                "type": {
                    "name": "type",
                    "documentation": "Type of address, e.g. electronic,  locality. Taken from value of inherited `_name_` attribute.",
                    "result": {
                        "type": "DV_TEXT"
                    }
                }
            },
            "invariants": {
                "Type_valid": "type = name"
            }
        },
        "PARTY_IDENTITY": {
            "name": "PARTY_IDENTITY",
            "documentation": "An identity  owned  by a Party, such as a person name or company name, and which is used by the Party to identify itself. Actual structure is archetyped.",
            "ancestors": [
                "LOCATABLE"
            ],
            "properties": {
                "details": {
                    "name": "details",
                    "documentation": "The value of the identity. This will often taken the form of a parseable string or a small structure of strings.",
                    "is_mandatory": true,
                    "type": "ITEM_STRUCTURE"
                }
            },
            "functions": {
                "purpose": {
                    "name": "purpose",
                    "documentation": "Purpose of identity, e.g. legal ,  stagename,  nickname,  tribal name,  trading name. Taken from value of inherited `_name_` attribute.",
                    "result": {
                        "type": "DV_TEXT"
                    }
                }
            },
            "invariants": {
                "Purpose_valid": "purpose = name"
            }
        },
        "ROLE": {
            "name": "ROLE",
            "documentation": "Generic description of a role performed by an Actor. The role corresponds to a competency of the Party. Roles are used to define the responsibilities undertaken by a Party for a purpose. Roles should have credentials qualifying the performer to perform the role.",
            "ancestors": [
                "PARTY"
            ],
            "properties": {
                "time_validity": {
                    "_type": "P_BMM_GENERIC_PROPERTY",
                    "name": "time_validity",
                    "documentation": "Valid time interval for this role.",
                    "type_def": {
                        "root_type": "DV_INTERVAL",
                        "generic_parameters": [
                            "DV_DATE"
                        ]
                    }
                },
                "performer": {
                    "name": "performer",
                    "documentation": "Reference to Version container of Actor playing the role.",
                    "is_mandatory": true,
                    "type": "PARTY_REF"
                },
                "capabilities": {
                    "_type": "P_BMM_CONTAINER_PROPERTY",
                    "name": "capabilities",
                    "documentation": "The capabilities of this role.",
                    "type_def": {
                        "container_type": "List",
                        "type": "CAPABILITY"
                    },
                    "cardinality": {
                        "lower": 0,
                        "upper_unbounded": true
                    }
                }
            },
            "invariants": {
                "Capabilities_valid": "capabilities \/= Void implies not capabilities.empty"
            }
        },
        "ACTOR": {
            "name": "ACTOR",
            "documentation": "Ancestor of all real-world types, including people and organisations. An actor is any real-world entity capable of taking on a role.",
            "is_abstract": true,
            "ancestors": [
                "PARTY"
            ],
            "properties": {
                "languages": {
                    "_type": "P_BMM_CONTAINER_PROPERTY",
                    "name": "languages",
                    "documentation": "Languages which can be used to communicate with this actor, in preferred order of use (if known, else order irrelevant).",
                    "type_def": {
                        "container_type": "List",
                        "type": "DV_TEXT"
                    },
                    "cardinality": {
                        "lower": 0,
                        "upper_unbounded": true
                    }
                },
                "roles": {
                    "_type": "P_BMM_CONTAINER_PROPERTY",
                    "name": "roles",
                    "documentation": "Identifiers of the Version container for each Role played by this Party.",
                    "type_def": {
                        "container_type": "List",
                        "type": "PARTY_REF"
                    },
                    "cardinality": {
                        "lower": 0,
                        "upper_unbounded": true
                    }
                }
            },
            "invariants": {
                "Roles_valid": "roles \/= Void implies not roles.is_empty",
                "Legal_identity_exists": "has_legal_identity"
            }
        },
        "CAPABILITY": {
            "name": "CAPABILITY",
            "documentation": "Capability of a role, such as  ehr modifier,  health care provider. Capability should be backed up by credentials.",
            "ancestors": [
                "LOCATABLE"
            ],
            "properties": {
                "credentials": {
                    "name": "credentials",
                    "documentation": "The qualifications of the performer of the role for this capability. This might include professional qualifications and official identifications such as provider numbers etc.",
                    "is_mandatory": true,
                    "type": "ITEM_STRUCTURE"
                },
                "time_validity": {
                    "_type": "P_BMM_GENERIC_PROPERTY",
                    "name": "time_validity",
                    "documentation": "Valid time interval for the credentials of this capability.",
                    "type_def": {
                        "root_type": "DV_INTERVAL",
                        "generic_parameters": [
                            "DV_DATE"
                        ]
                    }
                }
            }
        },
        "AGENT": {
            "name": "AGENT",
            "documentation": "Generic concept of any kind of agent, including devices, software systems, but not humans or organisations.",
            "ancestors": [
                "ACTOR"
            ]
        },
        "ORGANISATION": {
            "name": "ORGANISATION",
            "documentation": "Generic description of organisations. An organisation is a legally constituted body whose existence (in general) outlives the existence of parties considered to be part of it.",
            "ancestors": [
                "ACTOR"
            ]
        },
        "GROUP": {
            "name": "GROUP",
            "documentation": "A group is a real world group of parties which is created by another party, usually an organisation, for some specific purpose. A typical clinical example is that of the specialist care team, e.g.  cardiology team . The members of the group usually work together.",
            "ancestors": [
                "ACTOR"
            ]
        },
        "PERSON": {
            "name": "PERSON",
            "documentation": "Generic description of persons. Provides a dedicated type to which Person archetypes can be targeted.",
            "ancestors": [
                "ACTOR"
            ]
        },
        "PARTY_RELATIONSHIP": {
            "name": "PARTY_RELATIONSHIP",
            "documentation": "Generic description of a relationship between parties.",
            "ancestors": [
                "LOCATABLE"
            ],
            "properties": {
                "details": {
                    "name": "details",
                    "documentation": "The detailed description of the relationship.",
                    "type": "ITEM_STRUCTURE"
                },
                "target": {
                    "name": "target",
                    "documentation": "Target of relationship.",
                    "is_mandatory": true,
                    "type": "PARTY_REF"
                },
                "time_validity": {
                    "_type": "P_BMM_GENERIC_PROPERTY",
                    "name": "time_validity",
                    "documentation": "Valid time interval for this relationship.",
                    "type_def": {
                        "root_type": "DV_INTERVAL",
                        "generic_parameters": [
                            "DV_DATE"
                        ]
                    }
                },
                "source": {
                    "name": "source",
                    "documentation": "Source of relationship.",
                    "is_mandatory": true,
                    "type": "PARTY_REF"
                }
            },
            "functions": {
                "type": {
                    "name": "type",
                    "documentation": "Type of relationship, such as  employment,  authority,  health provision ",
                    "result": {
                        "type": "DV_TEXT"
                    }
                }
            },
            "invariants": {
                "Source_valid": "source \/= Void and then source.relationships.has (self)",
                "Target_valid": "target \/= Void and then not target.reverse_relationships.has (self)",
                "Type_validity": "type = name"
            }
        },
        "VERSIONED_PARTY": {
            "name": "VERSIONED_PARTY",
            "documentation": "Static type formed by binding generic parameter of `VERSIONED_OBJECT<T>` to `PARTY`. ",
            "ancestors": [
                "VERSIONED_OBJECT"
            ]
        },
        "GENERIC_ENTRY": {
            "name": "GENERIC_ENTRY",
            "documentation": "This class is used to create intermediate representations of data from sources not otherwise conforming to openEHR classes, such as HL7 messages, relational databases and so on.",
            "ancestors": [
                "CONTENT_ITEM"
            ],
            "properties": {
                "data": {
                    "name": "data",
                    "documentation": "The data from the source message or record. May be recorded in any structural openEHR representation.",
                    "is_mandatory": true,
                    "type": "ITEM"
                }
            }
        },
        "COMPOSITION": {
            "name": "COMPOSITION",
            "documentation": "Content of one version in a `VERSIONED_COMPOSITION`. A Composition is considered the unit of modification of the record, the unit of transmission in record Extracts, and the unit of attestation by authorising clinicians. In this latter sense, it may be considered equivalent to a signed document.\n\nNOTE: It is strongly recommended that the inherited attribute `_uid_` be populated in Compositions, using the UID copied from the `_object_id()_` of the `_uid_` field of the enclosing `VERSION` object. +\nFor example, the `ORIGINAL_VERSION.uid` `87284370-2D4B-4e3d-A3F3-F303D2F4F34B::uk.nhs.ehr1::2` would be copied to the `_uid_` field of the Composition.",
            "ancestors": [
                "LOCATABLE"
            ],
            "properties": {
                "language": {
                    "name": "language",
                    "documentation": "Mandatory indicator of the localised language in which this Composition is written. Coded from openEHR Code Set  `languages`. The language of an Entry if different from the Composition is indicated in `ENTRY._language_`. ",
                    "is_mandatory": true,
                    "type": "CODE_PHRASE"
                },
                "territory": {
                    "name": "territory",
                    "documentation": "Name of territory in which this Composition was written. Coded from openEHR  countries  code set, which is an expression of the ISO 3166 standard.",
                    "is_mandatory": true,
                    "type": "CODE_PHRASE"
                },
                "category": {
                    "name": "category",
                    "documentation": "Temporal category of this Composition, i.e. \n\n* `431|persistent|` - of potential life-time validity;\n* `451|episodic|` - valid over the life of a care episode;\n* `433|event|` - valid at the time of recording (long-term validity requires subsequent clinical assessment).\n\nor any other code defined in the openEHR terminology group 'category'.\n",
                    "is_mandatory": true,
                    "type": "DV_CODED_TEXT"
                },
                "context": {
                    "name": "context",
                    "documentation": "The clinical session context of this Composition, i.e. the contextual attributes of the clinical session. ",
                    "type": "EVENT_CONTEXT"
                },
                "composer": {
                    "name": "composer",
                    "documentation": "The person primarily responsible for the content of the Composition (but not necessarily its committal into the EHR system). This is the identifier which should appear on the screen. It may or may not be the person who entered the data. When it is the patient, the special self  instance of `PARTY_PROXY` will be used.",
                    "is_mandatory": true,
                    "type": "PARTY_PROXY"
                },
                "content": {
                    "_type": "P_BMM_CONTAINER_PROPERTY",
                    "name": "content",
                    "documentation": "The content of this Composition. ",
                    "type_def": {
                        "container_type": "List",
                        "type": "CONTENT_ITEM"
                    },
                    "cardinality": {
                        "lower": 0,
                        "upper_unbounded": true
                    }
                }
            },
            "functions": {
                "is_persistent": {
                    "name": "is_persistent",
                    "documentation": "True if category is `431|persistent|`, False otherwise. Useful for finding Compositions in an EHR which are guaranteed to be of interest to most users. ",
                    "result": {
                        "type": "Boolean"
                    }
                }
            },
            "invariants": {
                "Setting_valid": "",
                "unnamed2": "",
                "unnamed3": "Terminology (Terminology_id_openehr).has_code_for_group_id (Group_id_setting, setting.defining_code)",
                "Category_validity": "terminology (Terminology_id_openehr).has_code_for_group_id (Group_id_composition_category, category.defining_code)",
                "Is_persistent_validity": "is_persistent implies context = Void",
                "Territory_valid": "code_set(Code_set_id_countries).has_code(territory)",
                "Language_valid": "code_set(Code_set_id_languages).has_code(language)",
                "Content_valid": "content \/= Void implies not content.is_empty",
                "Is_archetype_root": "is_archetype_root"
            }
        },
        "EVENT_CONTEXT": {
            "name": "EVENT_CONTEXT",
            "documentation": "Documents the context information of a healthcare event involving the subject of care and the health system. The context information recorded here are independent of the attributes recorded in the version audit, which document the  system interaction  context, i.e. the context of a user interacting with the health record system. Healthcare events include patient contacts, and any other business activity, such as pathology investigations which take place on behalf of the patient. ",
            "ancestors": [
                "PATHABLE"
            ],
            "properties": {
                "start_time": {
                    "name": "start_time",
                    "documentation": "Start time of the clinical session or other kind of event during which a provider performs a service of any kind for the patient. ",
                    "is_mandatory": true,
                    "type": "DV_DATE_TIME"
                },
                "end_time": {
                    "name": "end_time",
                    "documentation": "Optional end time of the clinical session. \n",
                    "type": "DV_DATE_TIME"
                },
                "location": {
                    "name": "location",
                    "documentation": "The actual location where the session occurred, e.g. 'microbiology lab 2', 'home', 'ward A3'  and so on.",
                    "type": "String"
                },
                "setting": {
                    "name": "setting",
                    "documentation": "The setting in which the clinical session took place. Coded using the openEHR Terminology,  setting  group. ",
                    "is_mandatory": true,
                    "type": "DV_CODED_TEXT"
                },
                "other_context": {
                    "name": "other_context",
                    "documentation": "Other optional context which will be archetyped.",
                    "type": "ITEM_STRUCTURE"
                },
                "health_care_facility": {
                    "name": "health_care_facility",
                    "documentation": "The health care facility under whose care the event took place. This is the most specific workgroup or delivery unit within a care delivery enterprise that has an official identifier in the health system, and can be used to ensure medico-legal accountability. ",
                    "type": "PARTY_IDENTIFIED"
                },
                "participations": {
                    "_type": "P_BMM_CONTAINER_PROPERTY",
                    "name": "participations",
                    "documentation": "Parties involved in the healthcare event. These would normally include the physician(s) and often the patient (but not the latter if the clinical session is a pathology test for example). ",
                    "type_def": {
                        "container_type": "List",
                        "type": "PARTICIPATION"
                    },
                    "cardinality": {
                        "lower": 0,
                        "upper_unbounded": true
                    }
                }
            },
            "invariants": {
                "Setting_valid": "Terminology (Terminology_id_openehr).has_code_for_group_id (Group_id_setting, setting.defining_code)",
                "Participations_validity": "participations \/= Void implies not participations.is_empty",
                "location_valid": "location \/= Void implies not location.is_empty"
            }
        },
        "CONTENT_ITEM": {
            "name": "CONTENT_ITEM",
            "documentation": "Abstract ancestor of all concrete content types.",
            "is_abstract": true,
            "ancestors": [
                "LOCATABLE"
            ]
        },
        "SECTION": {
            "name": "SECTION",
            "documentation": "Represents a heading in a heading structure, or  section tree.  Created according to archetyped structures for typical headings such as SOAP,  physical examination, but also pathology result heading structures.  Should not be used instead of `ENTRY` hierarchical structures. \n",
            "ancestors": [
                "CONTENT_ITEM"
            ],
            "properties": {
                "items": {
                    "_type": "P_BMM_CONTAINER_PROPERTY",
                    "name": "items",
                    "documentation": "Ordered list of content items under this section, which may include:\n\n* more `SECTIONs`;\n* `ENTRYs`.",
                    "type_def": {
                        "container_type": "List",
                        "type": "CONTENT_ITEM"
                    },
                    "cardinality": {
                        "lower": 0,
                        "upper_unbounded": true
                    }
                }
            },
            "invariants": {
                "Items_valid": "items \/= Void implies not items.is_empty"
            }
        },
        "ADMIN_ENTRY": {
            "name": "ADMIN_ENTRY",
            "documentation": "Entry subtype for administrative information, i.e. information about setting up the clinical process, but not itself clinically relevant. Archetypes will define contained information.\n\nUsed for administrative details of admission, episode, ward location, discharge, appointment (if not stored in a practice management or appointments system). \n\nNot to be used for any clinically significant information.",
            "ancestors": [
                "ENTRY"
            ],
            "properties": {
                "data": {
                    "name": "data",
                    "documentation": "Content of the Admin Entry.",
                    "is_mandatory": true,
                    "type": "ITEM_STRUCTURE"
                }
            }
        },
        "CARE_ENTRY": {
            "name": "CARE_ENTRY",
            "documentation": "The abstract parent of all clinical `ENTRY` subtypes. A `CARE_ENTRY` defines protocol and guideline attributes for all clinical Entry subtypes. ",
            "is_abstract": true,
            "ancestors": [
                "ENTRY"
            ],
            "properties": {
                "protocol": {
                    "name": "protocol",
                    "documentation": "Description of the method (i.e. how) the information in this entry was arrived at. For `OBSERVATIONs`, this is a description of the method or instrument used. For `EVALUATIONs`, how the evaluation was arrived at. For `INSTRUCTIONs`, how to execute the Instruction. This may take the form of references to guidelines, including manually followed and executable; knowledge references such as a paper in Medline; clinical reasons within a larger care process. ",
                    "type": "ITEM_STRUCTURE"
                },
                "guideline_id": {
                    "name": "guideline_id",
                    "documentation": "Optional external identifier of guideline creating this Entry if relevant.",
                    "type": "OBJECT_REF"
                }
            }
        },
        "OBSERVATION": {
            "name": "OBSERVATION",
            "documentation": "Entry subtype for all clinical data in the past or present, i.e. which (by the time it is recorded) has already occurred. `OBSERVATION` data is expressed using the class `HISTORY<T>`, which guarantees that it is situated in time. `OBSERVATION` is used for all notionally objective (i.e. measured in some way) observations of phenomena, and patient-reported phenomena, e.g. pain. \n\nNot to be used for recording opinion or future statements of any kind, including instructions, intentions, plans etc.",
            "ancestors": [
                "CARE_ENTRY"
            ],
            "properties": {
                "data": {
                    "_type": "P_BMM_GENERIC_PROPERTY",
                    "name": "data",
                    "documentation": "The data of this observation, in the form of a history of values which may be of any complexity.",
                    "is_mandatory": true,
                    "type_def": {
                        "root_type": "HISTORY",
                        "generic_parameters": [
                            "ITEM_STRUCTURE"
                        ]
                    }
                },
                "state": {
                    "_type": "P_BMM_GENERIC_PROPERTY",
                    "name": "state",
                    "documentation": "Optional recording of the state of subject of this observation during the observation process, in the form of a separate history of values which may be of any complexity. State may also be recorded within the History of the data attribute. ",
                    "type_def": {
                        "root_type": "HISTORY",
                        "generic_parameters": [
                            "ITEM_STRUCTURE"
                        ]
                    }
                }
            }
        },
        "EVALUATION": {
            "name": "EVALUATION",
            "documentation": "Entry type for evaluation statements. Used for all kinds of statements which evaluate other information, such as interpretations of observations, diagnoses, differential diagnoses, hypotheses, risk assessments, goals and plans. \n\nShould not be used for actionable statements such as medication orders - these are represented using the `INSTRUCTION` type. ",
            "ancestors": [
                "CARE_ENTRY"
            ],
            "properties": {
                "data": {
                    "name": "data",
                    "documentation": "The data of this evaluation, in the form of a spatial data structure.",
                    "is_mandatory": true,
                    "type": "ITEM_STRUCTURE"
                }
            }
        },
        "ACTION": {
            "name": "ACTION",
            "documentation": "Used to record a clinical action that has been performed, which may have been ad hoc, or due to the execution of an Activity in an Instruction workflow. Every Action corresponds to a careflow step of some kind or another. ",
            "ancestors": [
                "CARE_ENTRY"
            ],
            "properties": {
                "time": {
                    "name": "time",
                    "documentation": "Point in time at which this action completed. To indicate an unknown time, use a `DV_DATE_TIME` instance with `_value_` set to the time of creation (or some other known time before which the Action is known to have occurred, e.g. data accession timestamp from integration engine), and `_magnitude_status_` set to `<`.",
                    "is_mandatory": true,
                    "type": "DV_DATE_TIME"
                },
                "ism_transition": {
                    "name": "ism_transition",
                    "documentation": "Details of transition in the Instruction state machine caused by this Action.",
                    "is_mandatory": true,
                    "type": "ISM_TRANSITION"
                },
                "instruction_details": {
                    "name": "instruction_details",
                    "documentation": "Details of the Instruction that caused this Action to be performed, if there was one.",
                    "type": "INSTRUCTION_DETAILS"
                },
                "description": {
                    "name": "description",
                    "documentation": "Description of the action that has been performed, in the form of an archetyped structure.",
                    "is_mandatory": true,
                    "type": "ITEM_STRUCTURE"
                }
            }
        },
        "ACTIVITY": {
            "name": "ACTIVITY",
            "documentation": "Defines a single activity within an Instruction, such as a medication administration. ",
            "ancestors": [
                "LOCATABLE"
            ],
            "properties": {
                "timing": {
                    "name": "timing",
                    "documentation": "Timing of the activity, in the form of a parsable string. If used, the preferred syntax is ISO8601 'R' format, but other formats may be used including HL7 GTS.\n\nMay be omitted if:\n\n* timing is represented structurally in the `_description_` attribute (e.g. via archetyped elements), or\n* unavailable, e.g. imported legacy data; in such cases, the `INSTRUCTION._narrative_` should carry text that indicates the timing of its `_activities_`.",
                    "type": "DV_PARSABLE"
                },
                "action_archetype_id": {
                    "name": "action_archetype_id",
                    "documentation": "Perl-compliant regular expression pattern, enclosed in  '\/\/' delimiters, indicating the valid identifiers of archetypes for Actions corresponding to this Activity specification. \n\nDefaults to  `\/.*\/`, meaning any archetype.",
                    "is_mandatory": true,
                    "type": "String"
                },
                "description": {
                    "name": "description",
                    "documentation": "Description of the activity, in the form of an archetyped structure.",
                    "is_mandatory": true,
                    "type": "ITEM_STRUCTURE"
                }
            },
            "invariants": {
                "Action_archetype_id_valid": "not action_archetype_id.is_empty"
            }
        },
        "ISM_TRANSITION": {
            "name": "ISM_TRANSITION",
            "documentation": "Model of a transition in the Instruction State Machine, caused by a careflow step. The attributes document the careflow step as well as the ISM transition. ",
            "ancestors": [
                "PATHABLE"
            ],
            "properties": {
                "current_state": {
                    "name": "current_state",
                    "documentation": "The ISM current state. Coded by openEHR terminology group Instruction states.",
                    "is_mandatory": true,
                    "type": "DV_CODED_TEXT"
                },
                "transition": {
                    "name": "transition",
                    "documentation": "The ISM transition which occurred to arrive in the current_state. Coded by openEHR terminology group  Instruction transitions.",
                    "type": "DV_CODED_TEXT"
                },
                "careflow_step": {
                    "name": "careflow_step",
                    "documentation": "The step in the careflow process which occurred as part of generating this action, e.g.  dispense ,  start_administration. This attribute represents the clinical  label for the activity, as  opposed to current_state which represents  the state machine (ISM)  computable form. Defined in archetype.",
                    "type": "DV_CODED_TEXT"
                },
                "reason": {
                    "_type": "P_BMM_CONTAINER_PROPERTY",
                    "name": "reason",
                    "documentation": "Optional possibility of adding one or more reasons for this careflow step having been taken. Multiple reasons may occur in medication management for example.",
                    "type_def": {
                        "container_type": "List",
                        "type": "DV_TEXT"
                    },
                    "cardinality": {
                        "lower": 0,
                        "upper_unbounded": true
                    }
                }
            },
            "invariants": {
                "Current_state_valid": "terminology (Terminology_id_openehr).has_code_for_group_id (Group_id_instruction_states, current_state.defining_code)",
                "Transition_valid": "transition \/= Void implies terminology (Terminology_id_openehr).\nhas_code_for_group_id (Group_id_instruction_transitions, transition.defining_code)"
            }
        },
        "INSTRUCTION_DETAILS": {
            "name": "INSTRUCTION_DETAILS",
            "documentation": "Used to record details of the Instruction causing an Action. \n",
            "ancestors": [
                "PATHABLE"
            ],
            "properties": {
                "instruction_id": {
                    "name": "instruction_id",
                    "documentation": "Reference to causing Instruction.",
                    "is_mandatory": true,
                    "type": "LOCATABLE_REF"
                },
                "activity_id": {
                    "name": "activity_id",
                    "documentation": "Identifier of Activity within Instruction, in the form of its archetype path. ",
                    "is_mandatory": true,
                    "type": "String"
                },
                "wf_details": {
                    "name": "wf_details",
                    "documentation": "Various workflow engine state details, potentially including such things as:\n\n* condition that fired to cause this Action to be done (with actual variables substituted); \n* list of notifications which actually occurred (with all variables substituted); \n* other workflow engine state. \n\nThis specification does not currently define the actual structure or semantics of this field. \n",
                    "type": "ITEM_STRUCTURE"
                }
            },
            "invariants": {
                "Activity_path_valid": "not activity_id.is_empty"
            }
        },
        "ENTRY": {
            "name": "ENTRY",
            "documentation": "The abstract parent of all `ENTRY` subtypes. An `ENTRY` is the root of a logical item of  hard  clinical information created in the  clinical statement  context, within a clinical session. There can be numerous such contexts in a clinical session. Observations and other Entry types only ever document information captured\/created in the event documented by the enclosing Composition.\n\nAn `ENTRY` is also the minimal unit of information any query should return, since a whole `ENTRY` (including subparts) records spatial structure, timing information, and contextual information, as well as the subject and generator of the information. ",
            "is_abstract": true,
            "ancestors": [
                "CONTENT_ITEM"
            ],
            "properties": {
                "language": {
                    "name": "language",
                    "documentation": "Mandatory indicator of the localised language in which this Entry is written. Coded from openEHR Code Set  languages . ",
                    "is_mandatory": true,
                    "type": "CODE_PHRASE"
                },
                "encoding": {
                    "name": "encoding",
                    "documentation": "Name of character set in which text values in this Entry are encoded. Coded from openEHR Code Set  character sets.",
                    "is_mandatory": true,
                    "type": "CODE_PHRASE"
                },
                "other_participations": {
                    "_type": "P_BMM_CONTAINER_PROPERTY",
                    "name": "other_participations",
                    "documentation": "Other participations at `ENTRY` level. ",
                    "type_def": {
                        "container_type": "List",
                        "type": "PARTICIPATION"
                    },
                    "cardinality": {
                        "lower": 0,
                        "upper_unbounded": true
                    }
                },
                "workflow_id": {
                    "name": "workflow_id",
                    "documentation": "Identifier of externally held workflow engine data for this workflow execution, for this subject of care.",
                    "type": "OBJECT_REF"
                },
                "subject": {
                    "name": "subject",
                    "documentation": "Id of human subject of this `ENTRY`, e.g.: \n\n* organ donor \n* foetus \n* a family member \n* another clinically relevant person.",
                    "is_mandatory": true,
                    "type": "PARTY_PROXY"
                },
                "provider": {
                    "name": "provider",
                    "documentation": "Optional identification of provider of the information in this `ENTRY`, which might be: \n\n* the patient \n* a patient agent, e.g. parent, guardian \n* the clinician \n* a device or software \n\nGenerally only used when the recorder needs to make it explicit. Otherwise, Composition composer and other participants are assumed. \n",
                    "type": "PARTY_PROXY"
                }
            },
            "functions": {
                "subject_is_self": {
                    "name": "subject_is_self",
                    "documentation": "Returns True if this Entry is about the subject of the EHR, in which case the subject attribute is of type PARTY_SELF.",
                    "post_conditions": {
                        "Post_condition": "Result implies subject.generating_type = \u201cPARTY_SELF\u201d"
                    },
                    "result": {
                        "type": "Boolean"
                    }
                }
            },
            "invariants": {
                "Language_valid": "code_set (Code_set_id_languages).has_code (language)",
                "Encoding_valid": "code_set (Code_set_id_character_sets).has_code (encoding)",
                "Subject_validity": "subject_is_self implies subject.generating_type = \u201cPARTY_SELF\u201d",
                "Other_participations_valid": "other_participations \/= Void implies not other_participations.is_empty",
                "Is_archetype_root": "is_archetype_root"
            }
        },
        "INSTRUCTION": {
            "name": "INSTRUCTION",
            "documentation": "Used to specify actions in the future. Enables simple and complex specifications to be expressed, including in a fully-computable workflow form. Used for any actionable statement such as medication and therapeutic orders, monitoring, recall and review. Enough details must be provided for the specification to be directly executed by an actor, either human or machine. \n\nNot to be used for plan items which are only specified in general terms. ",
            "ancestors": [
                "CARE_ENTRY"
            ],
            "properties": {
                "narrative": {
                    "name": "narrative",
                    "documentation": "Mandatory human-readable version of what the Instruction is about. ",
                    "is_mandatory": true,
                    "type": "DV_TEXT"
                },
                "expiry_time": {
                    "name": "expiry_time",
                    "documentation": "Optional expiry date\/time to assist determination of when an Instruction can be assumed to have expired. This helps prevent false listing of Instructions as Active when they clearly must have been terminated in some way or other. ",
                    "type": "DV_DATE_TIME"
                },
                "wf_definition": {
                    "name": "wf_definition",
                    "documentation": "Optional workflow engine executable expression of the Instruction. ",
                    "type": "DV_PARSABLE"
                },
                "activities": {
                    "_type": "P_BMM_CONTAINER_PROPERTY",
                    "name": "activities",
                    "documentation": "List of all activities in Instruction. \n",
                    "type_def": {
                        "container_type": "List",
                        "type": "ACTIVITY"
                    },
                    "cardinality": {
                        "lower": 0,
                        "upper_unbounded": true
                    }
                }
            },
            "invariants": {
                "Activities_valid": "activities \/= Void implies not activities.is_empty"
            }
        }
    }
}
